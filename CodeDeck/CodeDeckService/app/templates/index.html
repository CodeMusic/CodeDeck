<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeDeck Neural Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }
        
        .header h1 {
            margin-bottom: 8px;
        }
        
        .header p {
            opacity: 0.8;
            font-size: 14px;
        }
        
        .status-bar {
            background: #34495e;
            color: white;
            padding: 10px 20px;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #27ae60;
        }
        
        .chat-container {
            height: 400px;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }
        
        .message {
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
            gap: 2px;
            position: relative;
        }
        
        .message.user {
            align-items: flex-end;
        }
        
        .message.assistant {
            align-items: flex-start;
        }
        
        .message-bubble {
            display: flex;
            gap: 12px;
        }
        
        .message-content {
            max-width: 70%;
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
        }
        
        .message.user .message-content {
            background: #007bff;
            color: white;
        }
        
        .message.assistant .message-content {
            background: white;
            border: 1px solid #e9ecef;
        }
        
        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }
        
        .message.user .message-avatar {
            background: #007bff;
            color: white;
        }
        
        .message.assistant .message-avatar {
            background: #6c757d;
            color: white;
        }
        
        .message-sender {
            font-size: 11px;
            color: #6c757d;
            margin: 0 12px;
        }
        
        .message.user .message-sender {
            text-align: right;
        }
        
        .message.assistant .message-sender {
            text-align: left;
        }
        
        .input-area {
            padding: 20px;
            border-top: 1px solid #e9ecef;
        }
        
        .model-selector {
            margin-bottom: 12px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }
        
        .model-selector select {
            flex: 1;
            min-width: 200px;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .model-selector select option {
            padding: 8px;
        }
        
        .model-selector select option:checked {
            background: linear-gradient(135deg, #4CAF50 0%, #2196F3 100%);
            color: white;
            font-weight: bold;
        }
        
        .clear-btn {
            padding: 6px 12px;
            background: #f8f9fa;
            color: #6c757d;
            border: 1px solid #ced4da;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
        }
        
        .clear-btn:hover {
            background: #e9ecef;
            color: #495057;
        }
        
        .input-group {
            display: flex;
            gap: 12px;
        }
        
        .input-group input {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid #ced4da;
            border-radius: 24px;
            font-size: 14px;
            outline: none;
        }
        
        .input-group input:focus {
            border-color: #007bff;
        }
        
        .send-btn {
            padding: 12px 24px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 24px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }
        
        .send-btn:hover {
            background: #0056b3;
        }
        
        .send-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        
        .interrupt-btn {
            display: none;
            position: absolute;
            right: 10px;
            bottom: 10px;
            padding: 6px 12px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            z-index: 10;
            transition: all 0.2s ease;
            opacity: 0.9;
        }
        
        .interrupt-btn:hover {
            background: #c0392b;
            opacity: 1;
        }
        
        /* Always show interrupt button during generation */
        .message-content.generating .interrupt-btn {
            display: block;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
            color: #6c757d;
        }
        
        .loading-model {
            font-weight: bold;
            color: #495057;
        }
        
        .typing-indicator {
            display: inline-block;
            padding: 8px 12px;
            background: #e9ecef;
            border-radius: 18px;
            margin: 4px 0;
            font-size: 13px;
        }
        
        .typing-indicator-text {
            font-size: 12px;
            color: #6c757d;
            margin-right: 6px;
            font-weight: 500;
        }
        
        .typing-dots {
            display: inline-flex;
            gap: 2px;
            vertical-align: middle;
            margin-left: 4px;
        }
        
        .typing-dot {
            width: 6px;
            height: 6px;
            background: #6c757d;
            border-radius: 50%;
            animation: typing-bounce 1.4s infinite ease-in-out;
            display: inline-block;
        }
        
        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typing-bounce {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }
        
        .thinking-section {
            margin: 8px 0;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            background: #f8f9fa;
        }
        
        .thinking-header {
            padding: 8px 12px;
            background: #e9ecef;
            cursor: pointer;
            font-size: 12px;
            color: #6c757d;
            border-radius: 6px 6px 0 0;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .thinking-header:hover {
            background: #dee2e6;
        }
        
        .thinking-content {
            padding: 12px;
            display: none;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 12px;
            color: #495057;
            white-space: pre-wrap;
            border-top: 1px solid #e9ecef;
        }
        
        .thinking-content.expanded {
            display: block;
        }
        
        .thinking-toggle {
            font-size: 10px;
            transition: transform 0.2s;
        }
        
        .thinking-toggle.expanded {
            transform: rotate(90deg);
        }
        
        /* Tag styling */
        .tag-content {
            font-style: italic;
            padding: 2px 4px;
            border-radius: 3px;
            margin: 0 1px;
        }
        
        .tag-content.think {
            background-color: rgba(76, 0, 153, 0.1);
            color: #4b0082; /* Indigo */
            border-left: 2px solid #4b0082;
        }
        
        .tag-content.reasoning {
            background-color: rgba(0, 128, 128, 0.1);
            color: #008080; /* Teal */
            border-left: 2px solid #008080;
        }
        
        .tag-content.plan {
            background-color: rgba(0, 100, 0, 0.1);
            color: #006400; /* Dark Green */
            border-left: 2px solid #006400;
        }
        
        .tag-content.observe {
            background-color: rgba(255, 69, 0, 0.1);
            color: #ff4500; /* Orange Red */
            border-left: 2px solid #ff4500;
        }
        
        .tag-content.critique {
            background-color: rgba(178, 34, 34, 0.1);
            color: #b22222; /* Firebrick */
            border-left: 2px solid #b22222;
        }
        
        .tag-content.custom {
            background-color: rgba(70, 130, 180, 0.1);
            color: #4682b4; /* Steel Blue */
            border-left: 2px solid #4682b4;
        }
        
        .tag-marker {
            opacity: 0.7;
            font-size: 11px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-style: normal;
            font-weight: bold;
            padding: 1px 2px;
            border-radius: 2px;
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .config-toggle {
            margin-left: 10px;
            cursor: pointer;
            font-size: 12px;
            color: #bbb;
        }
        
        .config-panel {
            display: none;
            padding: 10px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }
        
        .config-panel.visible {
            display: block;
        }
        
        .config-item {
            margin-bottom: 12px;
        }
        
        .config-item label {
            display: block;
            margin-bottom: 4px;
            font-size: 12px;
            color: #495057;
        }
        
        .config-item input, .config-item select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .config-section {
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 12px;
        }
        
        .config-section-title {
            font-size: 13px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #495057;
        }
        
        .config-item textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 12px;
            height: 80px;
            resize: vertical;
        }
        
        .config-row {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .config-col {
            flex: 1;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-container input[type="range"] {
            flex: 1;
        }
        
        .slider-value {
            width: 40px;
            text-align: center;
            font-size: 12px;
            color: #495057;
            background: #e9ecef;
            padding: 3px 5px;
            border-radius: 3px;
        }
        
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .toggle-switch input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-switch .toggle-label {
            cursor: pointer;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 13px;
            transition: all 0.2s ease;
            background: #f8f9fa;
            width: 100%;
            text-align: center;
            user-select: none;
        }
        
        .toggle-switch input[type="checkbox"]:checked + .toggle-label {
            background: #28a745;
            color: white;
            border-color: #28a745;
            font-weight: bold;
        }
        
        .toggle-switch input[type="checkbox"]:disabled + .toggle-label {
            opacity: 0.7;
            cursor: not-allowed;
            background: #e9ecef;
        }
        
        .message-attribution {
            font-size: 10px;
            color: #6c757d;
            margin-top: 4px;
            text-align: right;
            font-style: italic;
        }
        
        .model-change-notification {
            text-align: center;
            padding: 6px 12px;
            margin: 8px auto;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px dashed #ced4da;
            font-size: 12px;
            color: #6c757d;
            max-width: 80%;
        }
        
        .debug-panel {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-family: monospace;
            font-size: 12px;
            color: #495057;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .retry-btn {
            padding: 6px 12px;
            background: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .retry-btn:hover {
            background: #138496;
        }
        
        /* Persona Management Styles */
        .persona-panel {
            display: none;
            padding: 15px;
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
        }
        
        .persona-panel.visible {
            display: block;
        }
        
        .persona-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .persona-card {
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .persona-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .persona-card.selected {
            border-color: #007bff;
            background: rgba(0, 123, 255, 0.05);
        }
        
        .persona-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }
        
        .persona-name {
            font-weight: bold;
            margin-bottom: 4px;
            font-size: 14px;
        }
        
        .persona-description {
            font-size: 12px;
            color: #6c757d;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .persona-tags {
            margin-top: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .persona-tag {
            font-size: 10px;
            padding: 2px 4px;
            background: #e9ecef;
            border-radius: 3px;
            color: #495057;
        }
        
        .persona-form {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            background: white;
        }
        
        .persona-btn {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            border: none;
            margin-right: 5px;
        }
        
        .persona-btn.primary {
            background: #007bff;
            color: white;
        }
        
        .persona-btn.secondary {
            background: #6c757d;
            color: white;
        }
        
        .persona-btn.danger {
            background: #dc3545;
            color: white;
        }
        
        .persona-btn.success {
            background: #28a745;
            color: white;
        }
        
        /* Mode toggle styles */
        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 8px;
            padding: 4px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #dee2e6;
        }
        
        .mode-option {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
            font-weight: 500;
        }
        
        .mode-option:hover {
            background: #e9ecef;
        }
        
        .mode-option input[type="radio"] {
            margin: 0;
        }
        
        .mode-option input[type="radio"]:checked + span {
            color: #007bff;
            font-weight: 600;
        }
        
        /* Selection group styles */
        .selection-group {
            transition: all 0.3s ease;
        }
        
        .selection-group.disabled {
            opacity: 0.5;
            pointer-events: none;
            filter: grayscale(50%);
        }
        
        .selection-group.disabled select {
            background-color: #f8f9fa;
            color: #6c757d;
        }
        
        /* Audio control buttons */
        .audio-controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #e9ecef;
        }
        
        .audio-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #495057;
            transition: all 0.2s ease;
        }
        
        .audio-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }
        
        .audio-btn:active {
            background: #dee2e6;
        }
        
        .audio-btn.loading {
            opacity: 0.7;
            cursor: not-allowed;
        }
        
        .audio-btn.loading::after {
            content: '⏳';
            margin-left: 4px;
        }

        .audio-controls .audio-btn.loading {
            opacity: 0.7;
            cursor: not-allowed;
        }

        /* Personality Editor Styles */
        .personality-editor {
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            background: #f8f9fa;
            margin-top: 10px;
        }

        .persona-image-section {
            margin-bottom: 20px;
            text-align: center;
        }

        .image-selector {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .current-image {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .emoji-display {
            font-size: 48px;
            border: 2px solid #dee2e6;
            border-radius: 50%;
            width: 64px;
            height: 64px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
        }

        .change-image-btn {
            padding: 8px 16px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .change-image-btn:hover {
            background: #5a6268;
        }

        .personality-sections {
            display: grid;
            gap: 20px;
        }

        .personality-section {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
        }

        .personality-section label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
            display: block;
        }

        .personality-section textarea {
            width: 100%;
            min-height: 80px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            padding: 10px;
            resize: vertical;
            font-family: inherit;
            font-size: 14px;
        }

        .ocean-sliders {
            display: grid;
            gap: 15px;
        }

        .ocean-trait {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .ocean-trait label {
            min-width: 120px;
            margin-bottom: 0;
            font-size: 14px;
        }

        .ocean-trait input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
            -webkit-appearance: none;
        }

        .ocean-trait input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }

        .ocean-trait input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
        }

        .trait-value {
            min-width: 40px;
            text-align: right;
            font-weight: 600;
            color: #007bff;
        }
        
        /* Persona Test Section Styles */
        .persona-test-section {
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            background: white;
            margin-top: 10px;
        }

        .test-chat-container {
            height: 200px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 10px;
            background: #f8f9fa;
            margin-bottom: 10px;
        }

        .test-message {
            margin-bottom: 12px;
            display: flex;
            gap: 8px;
            align-items: flex-start;
        }

        .test-message.user {
            flex-direction: row-reverse;
        }

        .test-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #6c757d;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
        }

        .test-message.user .test-avatar {
            background: #007bff;
        }

        .test-content {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 13px;
            line-height: 1.4;
        }

        .test-message.assistant .test-content {
            background: white;
            border: 1px solid #dee2e6;
        }

        .test-message.user .test-content {
            background: #007bff;
            color: white;
        }

        .test-input-area {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .test-input-area input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 18px;
            font-size: 13px;
            outline: none;
        }

        .test-input-area input:focus {
            border-color: #007bff;
        }

        .test-input-area .persona-btn {
            margin: 0;
            font-size: 12px;
            padding: 8px 16px;
        }

        .test-message.typing .test-content {
            background: #e9ecef;
            font-style: italic;
            color: #6c757d;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🧠 CodeDeck Neural Interface</h1>
            <p>Local LLM Inference Hub</p>
        </div>
        
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Connecting...</span>
            </div>
            <div id="systemMetrics" style="font-size: 11px; color: #bbb;">Loading...</div>
            <div id="modelInfo">Loading models...</div>
            <div class="config-toggle" id="thinkTagsToggle" title="Toggle speaking think tags">💭</div>
            <div class="config-toggle" id="configToggleBtn">⚙️</div>
        </div>
        
        <!-- Debug panel (hidden by default) -->
        <div id="debugPanel" style="display: none;" class="debug-panel">
            <div id="debugOutput">No connection errors</div>
            <button class="retry-btn" onclick="retryConnection()">Retry Connection</button>
        </div>
        
        <!-- Audio elements for sound effects -->
        <audio id="sendSound" preload="auto">
            <source src="/static/sounds/send.wav" type="audio/wav">
        </audio>
        <audio id="receiveSound" preload="auto">
            <source src="/static/sounds/receive.wav" type="audio/wav">
        </audio>
        <audio id="switchSound" preload="auto">
            <source src="/static/sounds/switch.wav" type="audio/wav">
        </audio>
        <audio id="confirmSound" preload="auto">
            <source src="/static/sounds/confirm.wav" type="audio/wav">
        </audio>
        
        <div class="config-panel" id="configPanel">
            <div class="config-section">
                <div class="config-section-title">Connection Settings</div>
                <div class="config-item">
                    <label for="directModeToggle">Direct Mode:</label>
                    <div class="toggle-switch">
                        <input type="checkbox" id="directModeToggle">
                        <label for="directModeToggle" class="toggle-label">Enable Direct Mode</label>
                    </div>
                    <div style="font-size: 11px; color: #6c757d; margin-top: 4px;">
                        Direct mode reduces latency but may be less reliable with some models
                    </div>
                </div>
            </div>
            
            <div class="config-section">
                <div class="config-section-title">Generation Settings</div>
                <div class="config-item">
                    <label for="temperatureSlider">Temperature:</label>
                    <div class="slider-container">
                        <input type="range" id="temperatureSlider" min="0" max="1" step="0.05" value="0.7" oninput="updateTemperatureValue()">
                        <div class="slider-value" id="temperatureValue">0.7</div>
                    </div>
                    <div style="font-size: 11px; color: #6c757d; margin-top: 2px;">
                        Lower = more focused, Higher = more creative
                    </div>
                </div>
                
                <div class="config-row">
                    <div class="config-col">
                        <div class="config-item">
                            <label for="maxTokensInput">Max Tokens:</label>
                            <input type="number" id="maxTokensInput" min="64" max="4096" step="64" value="512" onchange="saveConfig()">
                        </div>
                    </div>
                    <div class="config-col">
                        <div class="config-item">
                            <label for="topPInput">Top-P:</label>
                            <input type="number" id="topPInput" min="0" max="1" step="0.05" value="0.9" onchange="saveConfig()">
                        </div>
                    </div>
                </div>
                
                <div class="config-item">
                    <label for="voiceModeSelect">Voice Mode:</label>
                    <select id="voiceModeSelect" onchange="saveConfig()">
                        <option value="text">Text Only (Manual Controls)</option>
                        <option value="audio_file">Auto-Play in Browser</option>
                        <option value="speak">Auto-Speak on Device</option>
                    </select>
                    <div style="font-size: 11px; color: #6c757d; margin-top: 2px;">
                        Controls automatic audio behavior (manual buttons always available)
                    </div>
                </div>
                
                <div class="config-item">
                    <label for="systemMessage">Persona:</label>
                    <textarea id="systemMessage" placeholder="Set a specific persona or role for the AI (e.g. 'You are a helpful coding assistant')" onchange="saveConfig()"></textarea>
                    <div style="font-size: 11px; color: #6c757d; margin-top: 2px;">
                        Provide instructions to guide the model's behavior
                    </div>
                </div>
                
                <div class="config-row">
                    <div class="config-col">
                        <div class="config-item">
                            <label for="maxContextInput">Max Context Length:</label>
                            <input type="number" id="maxContextInput" min="1" max="20" step="1" value="7" onchange="saveConfig()">
                            <div style="font-size: 11px; color: #6c757d; margin-top: 2px;">
                                Number of message pairs to remember
                            </div>
                        </div>
                    </div>
                    <div class="config-col">
                        <div class="config-item">
                            <label for="topPInput">Top-P:</label>
                            <input type="number" id="topPInput" min="0" max="1" step="0.05" value="0.9" onchange="saveConfig()">
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="config-section">
                <div class="config-section-title">
                    Persona Management
                    <button class="persona-btn primary" id="managePersonasBtn" style="float: right; margin-top: -5px;">
                        Manage Personas
                    </button>
                </div>
                <div class="config-item">
                    <label for="openaiApiKey">OpenAI API Key (Optional):</label>
                    <input type="password" id="openaiApiKey" placeholder="For generating system messages">
                    <div style="font-size: 11px; color: #6c757d; margin-top: 2px;">
                        Used only for generating system messages from descriptions
                    </div>
                </div>
                <div class="config-item" style="text-align: right; margin-top: 10px;">
                    <button class="persona-btn success" id="saveApiKeyBtn">Save API Key</button>
                </div>
            </div>
        </div>
        
        <!-- Persona Management Panel -->
        <div class="persona-panel" id="personaPanel">
            <div class="config-section-title">
                Persona Management
                <button class="persona-btn primary" id="newPersonaBtn" style="float: right; margin-top: -5px;">
                    Create New Persona
                </button>
            </div>
            
            <div class="persona-list" id="personaList">
                <!-- Personas will be loaded here -->
                <div style="grid-column: 1 / -1; text-align: center; padding: 20px; color: #6c757d;">
                    Loading personas...
                </div>
            </div>
            
            <div class="persona-form" id="personaForm" style="display: none;">
                <div class="config-section-title">
                    <span id="personaFormTitle">Create New Persona</span>
                </div>
                
                <div class="config-item">
                    <label for="personaName">Name:</label>
                    <input type="text" id="personaName" placeholder="Name your persona">
                </div>
                
                <div class="config-item">
                    <label for="personaDescription">Description:</label>
                    <input type="text" id="personaDescription" placeholder="Brief description">
                </div>
                
                <div class="config-row">
                    <div class="config-col">
                        <div class="config-item">
                            <label for="personaModel">Preferred Model:</label>
                            <select id="personaModel">
                                <option value="">Use Default</option>
                                <!-- Models will be populated here -->
                            </select>
                        </div>
                    </div>
                    <div class="config-col">
                        <div class="config-item">
                            <label for="personaIcon">Icon:</label>
                            <select id="personaIcon">
                                <option value="🤖">🤖 Robot</option>
                                <option value="👨‍💻">👨‍💻 Coder</option>
                                <option value="🧠">🧠 Brain</option>
                                <option value="🔍">🔍 Search</option>
                                <option value="📝">📝 Writing</option>
                                <option value="🎨">🎨 Creative</option>
                                <option value="📊">📊 Data</option>
                                <option value="🔬">🔬 Science</option>
                                <option value="🧪">🧪 Chemistry</option>
                                <option value="🧮">🧮 Math</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div class="config-row">
                    <div class="config-col">
                        <div class="config-item">
                            <label for="personaVoice">Voice:</label>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <select id="personaVoice" style="flex: 1;">
                                    <option value="">Loading voices...</option>
                                </select>
                                <button type="button" class="persona-btn secondary" id="sampleVoiceBtn" style="margin: 0; font-size: 11px; padding: 6px 10px;">
                                    🔊 Sample
                                </button>
                            </div>
                            <div style="font-size: 11px; color: #6c757d; margin-top: 2px;">
                                Voice used for text-to-speech responses
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="personality-editor">
                    <!-- Image selection -->
                    <div class="persona-image-section">
                        <label>Avatar Image</label>
                        <div class="image-selector">
                            <div class="current-image" id="currentPersonaImage">
                                <span class="emoji-display" id="personaEmojiDisplay">🤖</span>
                                <input type="file" id="personaImageFile" accept="image/*" style="display: none;">
                                <button type="button" class="change-image-btn" onclick="document.getElementById('personaImageFile').click()">Change</button>
                            </div>
                        </div>
                    </div>

                    <!-- Personality sections -->
                    <div class="personality-sections">
                        <div class="personality-section">
                            <label for="personalityOcean">OCEAN Personality</label>
                            <div class="ocean-sliders">
                                <div class="ocean-trait">
                                    <label>Openness</label>
                                    <input type="range" id="openness" min="0" max="100" value="75">
                                    <span class="trait-value">75%</span>
                                </div>
                                <div class="ocean-trait">
                                    <label>Conscientiousness</label>
                                    <input type="range" id="conscientiousness" min="0" max="100" value="85">
                                    <span class="trait-value">85%</span>
                                </div>
                                <div class="ocean-trait">
                                    <label>Extraversion</label>
                                    <input type="range" id="extraversion" min="0" max="100" value="60">
                                    <span class="trait-value">60%</span>
                                </div>
                                <div class="ocean-trait">
                                    <label>Agreeableness</label>
                                    <input type="range" id="agreeableness" min="0" max="100" value="70">
                                    <span class="trait-value">70%</span>
                                </div>
                                <div class="ocean-trait">
                                    <label>Neuroticism</label>
                                    <input type="range" id="neuroticism" min="0" max="100" value="25">
                                    <span class="trait-value">25%</span>
                                </div>
                            </div>
                        </div>

                        <div class="personality-section">
                            <label for="personaIdentity">Identity</label>
                            <textarea id="personaIdentity" placeholder="Who are you? Your role, background, and fundamental identity. Be direct and clear about who you are."></textarea>
                        </div>

                        <div class="personality-section">
                            <label for="personaCore">Core Philosophy</label>
                            <textarea id="personaCore" placeholder="What is their fundamental belief or truth about existence, knowledge, relationships, or purpose?"></textarea>
                        </div>

                        <div class="personality-section">
                            <label for="personaFramework">Behavioral Framework</label>
                            <textarea id="personaFramework" placeholder="What specific rules, triggers, or conditions shape how they interact? List their response patterns and communication guidelines."></textarea>
                        </div>

                        <div class="personality-section">
                            <label for="personaRecentEvents">Recent Context</label>
                            <textarea id="personaRecentEvents" placeholder="What recent experiences, memories, or contextual information influences their current responses?"></textarea>
                        </div>

                        <div class="personality-section">
                            <label for="personaTrance">Trigger States</label>
                            <textarea id="personaTrance" placeholder="What words, concepts, or scenarios shift their emotional state or alter their response patterns?"></textarea>
                        </div>

                        <div class="personality-section">
                            <label for="personaBehavior">Communication Style</label>
                            <textarea id="personaBehavior" placeholder="How do they interact? What's their tone, expertise areas, and response patterns?"></textarea>
                        </div>
                    </div>

                    <!-- Legacy system message field (hidden but maintained for compatibility) -->
                    <textarea id="personaSystemMessage" style="display: none;"></textarea>
                </div>

                <div class="config-item">
                    <div class="config-row">
                        <div class="config-col">
                            <label for="personaTemperature">Temperature:</label>
                            <input type="number" id="personaTemperature" min="0" max="1" step="0.05" value="0.7">
                        </div>
                        <div class="config-col">
                            <label for="personaMaxTokens">Max Tokens:</label>
                            <input type="number" id="personaMaxTokens" min="64" max="4096" step="64" value="512">
                        </div>
                    </div>
                </div>

                <div class="config-item">
                    <label for="personaTags">Tags (comma separated):</label>
                    <input type="text" id="personaTags" placeholder="e.g. creative, writing, stories">
                </div>

                <div class="config-section-title" style="margin-top: 15px; font-size: 12px;">
                    AI-Powered Generation
                </div>

                <div class="config-item">
                    <label for="generatorInput">Brief Description for AI Generation:</label>
                    <input type="text" id="generatorInput" placeholder="e.g. A coding tutor who explains things simply">
                </div>
                
                <div class="config-item" style="text-align: right;">
                    <button class="persona-btn secondary" id="generateSystemBtn">Generate Personality</button>
                    <button class="persona-btn secondary" id="regeneratePersonaBtn" style="display: none;">Regenerate</button>
                    <button class="persona-btn secondary" id="insertTemplateBtn">Reset Template</button>
                </div>
                
                <div class="config-section-title" style="margin-top: 20px; font-size: 12px;">
                    Test Persona
                </div>
                
                <div class="persona-test-section">
                    <div class="test-chat-container" id="testChatContainer">
                        <div class="test-message assistant">
                            <div class="test-avatar">🤖</div>
                            <div class="test-content">
                                Hello! I'm ready to be tested. Ask me anything to see how I respond with the current personality settings.
                            </div>
                        </div>
                    </div>
                    
                    <div class="test-input-area">
                        <input type="text" id="testMessageInput" placeholder="Type a test message to see how this persona responds...">
                        <button class="persona-btn primary" id="testPersonaBtn">Test Response</button>
                        <button class="persona-btn secondary" id="clearTestBtn">Clear</button>
                    </div>
                </div>
                
                <div class="config-item" style="text-align: right; margin-top: 15px; border-top: 1px solid #e9ecef; padding-top: 15px;">
                    <button class="persona-btn secondary" id="cancelPersonaBtn">Cancel</button>
                    <button class="persona-btn primary" id="savePersonaBtn">Save Persona</button>
                </div>
            </div>
        </div>
        
        <div class="chat-container" id="chatContainer">
            <div class="message assistant">
                <div class="message-avatar">🤖</div>
                <div class="message-content">
                    Hello! I'm your CodeDeck AI assistant. How can I help you today?
                </div>
            </div>
        </div>
        
        <div class="loading" id="loading">
            <div>🤔 <span class="loading-model" id="loadingModel">AI</span> is thinking...</div>
        </div>
        
        <div class="input-area">
            <div class="model-selector">
                <!-- Mode Toggle -->
                <div class="mode-toggle">
                    <label class="mode-option">
                        <input type="radio" name="selectionMode" value="manual" id="manualModeRadio" checked>
                        <span>Manual</span>
                    </label>
                    <label class="mode-option">
                        <input type="radio" name="selectionMode" value="persona" id="personaModeRadio">
                        <span>Persona</span>
                    </label>
                </div>
                
                <!-- Manual Mode Controls -->
                <div id="manualControls" class="selection-group">
                    <select id="modelSelect">
                        <option value="">Loading models...</option>
                    </select>
                </div>
                
                <!-- Persona Mode Controls -->
                <div id="personaControls" class="selection-group disabled">
                    <select id="personaSelect" style="max-width: 150px;">
                        <option value="">No Persona</option>
                    </select>
                </div>
                
                <button id="clearBtn" class="clear-btn">
                    Clear Context
                </button>
            </div>
            
            <div class="input-group">
                <input 
                    type="text" 
                    id="messageInput" 
                    placeholder="Type your message here..."
                >
                <button class="send-btn" id="sendBtn">
                    Send
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentModel = '';
        let isLoading = false;
        let conversationHistory = [];
        let isLocalConnection = false;
        let directInference = null;
        let useDirectMode = false; // Direct mode toggle
        let currentSelectionMode = 'manual'; // 'manual' or 'persona'
        let speakThinkTags = false; // Whether to include think tags in TTS
        
        // Generation settings
        let temperature = 0.7;
        let maxTokens = 512;
        let topP = 0.9;
        let systemMessage = '';
        let maxContextLength = 7; // Default max context length
        let voiceMode = 'speak'; // Default voice mode: text, audio_file, or speak
        
        // Declare variables for stream control
        let currentController = null;
        let isGenerating = false;
        
        // Tag colors map for consistency
        const tagColorMap = {
            'think': '#4b0082', // Indigo
            'reasoning': '#008080', // Teal
            'plan': '#006400', // Dark Green
            'observe': '#ff4500', // Orange Red
            'critique': '#b22222', // Firebrick
            // Dynamic entries will be added for custom tags
        };
        
        // Persona management variables
        let personas = [];
        let currentPersona = null;
        let editingPersonaId = null;
        
        // Function to safely get DOM elements with error handling
        function getElement(id) {
            const element = document.getElementById(id);
            if (!element) {
                console.warn(`Element with id '${id}' not found`);
            }
            return element;
        }
        
        // DOM-Ready event handler
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM content loaded, setting up event listeners");
            
            // Setup event listeners with null checks
            const configToggleBtn = getElement('configToggleBtn');
            if (configToggleBtn) {
                configToggleBtn.addEventListener('click', toggleConfig);
            }
            
            const modelSelect = getElement('modelSelect');
            if (modelSelect) {
                modelSelect.addEventListener('change', handleModelChange);
            }
            
            const personaSelect = getElement('personaSelect');
            if (personaSelect) {
                personaSelect.addEventListener('change', handlePersonaChange);
            }
            
            const sendBtn = getElement('sendBtn');
            if (sendBtn) {
                sendBtn.addEventListener('click', sendMessage);
            }
            
            const clearBtn = getElement('clearBtn');
            if (clearBtn) {
                clearBtn.addEventListener('click', clearConversation);
            }
            
            const messageInput = getElement('messageInput');
            if (messageInput) {
                messageInput.addEventListener('keypress', handleKeyPress);
            }
            
            const tempSlider = getElement('temperatureSlider');
            if (tempSlider) {
                tempSlider.addEventListener('input', updateTemperatureValue);
            }
            
            // Persona management event listeners
            const managePersonasBtn = getElement('managePersonasBtn');
            if (managePersonasBtn) {
                managePersonasBtn.addEventListener('click', togglePersonaPanel);
            }
            
            const newPersonaBtn = getElement('newPersonaBtn');
            if (newPersonaBtn) {
                newPersonaBtn.addEventListener('click', showNewPersonaForm);
            }
            
            const savePersonaBtn = getElement('savePersonaBtn');
            if (savePersonaBtn) {
                savePersonaBtn.addEventListener('click', savePersona);
            }
            
            const cancelPersonaBtn = getElement('cancelPersonaBtn');
            if (cancelPersonaBtn) {
                cancelPersonaBtn.addEventListener('click', hidePersonaForm);
            }
            
            const saveApiKeyBtn = getElement('saveApiKeyBtn');
            if (saveApiKeyBtn) {
                saveApiKeyBtn.addEventListener('click', saveApiKey);
            }
            
            const generateSystemBtn = getElement('generateSystemBtn');
            if (generateSystemBtn) {
                generateSystemBtn.addEventListener('click', generateSystemMessage);
            }
            
            const insertTemplateBtn = getElement('insertTemplateBtn');
            if (insertTemplateBtn) {
                insertTemplateBtn.addEventListener('click', insertPersonaTemplate);
            }
            
            // OCEAN slider event listeners
            const oceanTraits = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'neuroticism'];
            oceanTraits.forEach(trait => {
                const slider = getElement(trait);
                if (slider) {
                    slider.addEventListener('input', updateOceanValues);
                }
            });
            
            // Initialize OCEAN value displays
            updateOceanValues();
            
            // Initialize voice detection
            updateVoiceOptions();
            
            // Mode toggle event listeners
            const manualModeRadio = getElement('manualModeRadio');
            const personaModeRadio = getElement('personaModeRadio');
            
            if (manualModeRadio) {
                manualModeRadio.addEventListener('change', handleModeToggle);
            }
            
            if (personaModeRadio) {
                personaModeRadio.addEventListener('change', handleModeToggle);
            }
            
            // Initialize the app
            init();
        });
        
        // Initialize the app
        async function init() {
            console.log("Initializing CodeDeck app...");
            loadConfig();
            
            // Set initial status
            updateStatusIndicators('initializing', 'Connecting...');
            
            // Check server health first
            const isHealthy = await checkStatus();
            
            if (isHealthy) {
                console.log("Server is healthy, loading components...");
                await updateSystemMetrics();
                await loadModels();
                await loadPersonas();
                
                // Update model info display after loading
                setTimeout(() => {
                    updateModelInfo();
                }, 500);
            } else {
                console.error("Server health check failed - will use fallback models");
                updateStatusIndicators('error', 'Server unavailable');
                
                // Fallback for unavailable server
                const modelSelect = document.getElementById('modelSelect');
                const modelInfo = document.getElementById('modelInfo');
                
                if (modelSelect) {
                    modelSelect.innerHTML = '<option value="emergency-fallback">Emergency Fallback</option>';
                }
                
                if (modelInfo) {
                    modelInfo.innerHTML = `<span style="color: #e74c3c">⚠️ Server unreachable - using fallback</span>`;
                }
                
                currentModel = "emergency-fallback";
            }
            
            setInterval(updateSystemMetrics, 30000); // Update metrics every 30 seconds
            
            // Initialize model selection
            setTimeout(updateModelSelection, 1000);
            
            console.log("App initialization complete");
        }
        
        // Load available personas
        async function loadPersonas() {
            try {
                const response = await fetch('/v1/personas');
                
                if (response.ok) {
                    const data = await response.json();
                    personas = data.data || [];
                    
                    console.log(`Loaded ${personas.length} personas`);
                    
                    // Populate persona dropdown
                    updatePersonaDropdown();
                    
                    // Update persona list in management panel
                    updatePersonaList();
                } else {
                    console.warn("Error loading personas:", response.status);
                }
            } catch (error) {
                console.error('Error loading personas:', error);
            }
        }
        
        // Update persona dropdown in the main UI
        function updatePersonaDropdown() {
            const personaSelect = getElement('personaSelect');
            if (!personaSelect) return;
            
            // Clear current options except the default
            personaSelect.innerHTML = '<option value="">No Persona</option>';
            
            // Add personas to dropdown
            personas.forEach(persona => {
                const option = document.createElement('option');
                option.value = persona.id;
                option.textContent = `${persona.icon} ${persona.name}`;
                personaSelect.appendChild(option);
            });
        }
        
        // Update the persona list in the management panel
        function updatePersonaList() {
            const personaList = getElement('personaList');
            if (!personaList) return;
            
            // Clear current list
            personaList.innerHTML = '';
            
            // Show message if no personas
            if (personas.length === 0) {
                personaList.innerHTML = `
                    <div style="grid-column: 1 / -1; text-align: center; padding: 20px; color: #6c757d;">
                        No personas found. Create one to get started.
                    </div>
                `;
                return;
            }
            
            // Add personas to list
            personas.forEach(persona => {
                const card = document.createElement('div');
                card.className = 'persona-card';
                card.dataset.id = persona.id;
                
                // If this is the currently selected persona, mark it
                if (currentPersona && currentPersona.id === persona.id) {
                    card.classList.add('selected');
                }
                
                // Create tags HTML
                const tagsHtml = persona.tags.map(tag => 
                    `<div class="persona-tag">${tag}</div>`
                ).join('');
                
                card.innerHTML = `
                    <div class="persona-icon">${persona.icon}</div>
                    <div class="persona-name">${persona.name}</div>
                    <div class="persona-description">${persona.description}</div>
                    <div class="persona-tags">${tagsHtml}</div>
                `;
                
                // Add click handler
                card.addEventListener('click', () => selectPersonaCard(persona.id));
                
                personaList.appendChild(card);
            });
        }
        
        // Select a persona card in the management panel
        function selectPersonaCard(personaId) {
            // Deselect all cards
            const cards = document.querySelectorAll('.persona-card');
            cards.forEach(card => card.classList.remove('selected'));
            
            // Select the clicked card
            const selectedCard = document.querySelector(`.persona-card[data-id="${personaId}"]`);
            if (selectedCard) {
                selectedCard.classList.add('selected');
            }
            
            // Find the persona
            const persona = personas.find(p => p.id === personaId);
            if (!persona) return;
            
            // Display persona details in the form
            editingPersonaId = personaId;
            
            const personaFormTitle = getElement('personaFormTitle');
            if (personaFormTitle) {
                personaFormTitle.textContent = `Edit ${persona.name}`;
            }
            
            // Fill form fields
            const fields = {
                'personaName': persona.name,
                'personaDescription': persona.description,
                'personaModel': persona.model,
                'personaTemperature': persona.temperature,
                'personaMaxTokens': persona.max_tokens,
                'personaTags': persona.tags.join(', '),
                'personaVoice': persona.voice
            };
            
            for (const [id, value] of Object.entries(fields)) {
                const element = getElement(id);
                if (element) {
                    element.value = value;
                }
            }
            
            // Set emoji display
            const emojiDisplay = getElement('personaEmojiDisplay');
            if (emojiDisplay) {
                emojiDisplay.textContent = persona.icon || '🤖';
            }
            
            // Parse system message into personality editor
            if (persona.system_message) {
                parseSystemMessageToPersonality(persona.system_message);
            }
            
            // Set generator input from name and description for easy regeneration
            const generatorInput = getElement('generatorInput');
            if (generatorInput) {
                generatorInput.value = `${persona.name}: ${persona.description}`;
            }
            
            // Show regenerate button for existing personas
            showRegenerateButton();
            
            // Show the form
            const personaForm = getElement('personaForm');
            if (personaForm) {
                personaForm.style.display = 'block';
            }
        }
        
        // Toggle persona management panel
        function togglePersonaPanel() {
            const personaPanel = getElement('personaPanel');
            const configPanel = getElement('configPanel');
            
            if (personaPanel) {
                personaPanel.classList.toggle('visible');
                
                // If opening panel, load personas and populate model dropdown
                if (personaPanel.classList.contains('visible')) {
                    loadPersonas();
                    
                    // Populate the persona model dropdown with current models
                    populatePersonaModelDropdown();
                    
                    // Populate the persona voice dropdown with available voices
                    populatePersonaVoiceDropdown();
                    
                    // Hide config panel if it's open
                    if (configPanel && configPanel.classList.contains('visible')) {
                        configPanel.classList.remove('visible');
                    }
                }
            }
        }

        // Populate persona model dropdown with available models
        function populatePersonaModelDropdown() {
            const personaModelSelect = getElement('personaModel');
            if (!personaModelSelect) return;
            
            // Get the current models from the main model dropdown
            const modelSelect = getElement('modelSelect');
            if (!modelSelect) return;
            
            // Clear and rebuild the persona model dropdown
            personaModelSelect.innerHTML = '<option value="">Use Default</option>';
            
            // Copy options from the main model dropdown
            Array.from(modelSelect.options).forEach(option => {
                if (option.value) { // Skip empty values
                    const newOption = document.createElement('option');
                    newOption.value = option.value;
                    newOption.textContent = option.textContent;
                    personaModelSelect.appendChild(newOption);
                }
            });
        }
        
        // Show new persona form
        function showNewPersonaForm() {
            const personaForm = getElement('personaForm');
            const personaFormTitle = getElement('personaFormTitle');
            
            if (personaForm) {
                // Reset form
                editingPersonaId = null;
                
                if (personaFormTitle) {
                    personaFormTitle.textContent = 'Create New Persona';
                }
                
                // Clear form fields
                const fields = [
                    'personaName', 'personaDescription',
                    'personaTags', 'generatorInput'
                ];
                
                fields.forEach(id => {
                    const element = getElement(id);
                    if (element) {
                        element.value = '';
                    }
                });
                
                // Reset personality editor
                resetPersonalityEditor();
                
                // Set defaults for select and number fields
                const personaModel = getElement('personaModel');
                if (personaModel) {
                    personaModel.value = '';
                }
                
                const personaIcon = getElement('personaIcon');
                if (personaIcon) {
                    personaIcon.value = '🤖';
                }
                
                const personaTemperature = getElement('personaTemperature');
                if (personaTemperature) {
                    personaTemperature.value = '0.7';
                }
                
                const personaMaxTokens = getElement('personaMaxTokens');
                if (personaMaxTokens) {
                    personaMaxTokens.value = '512';
                }
                
                // Hide regenerate button for new personas
                hideRegenerateButton();
                
                // Show form
                personaForm.style.display = 'block';
            }
        }
        
        // Hide persona form
        function hidePersonaForm() {
            const personaForm = getElement('personaForm');
            if (personaForm) {
                personaForm.style.display = 'none';
            }
        }
        
        // Save persona (create or update)
        async function savePersona() {
            try {
                // Get form values
                const name = getElement('personaName').value.trim();
                const description = getElement('personaDescription').value.trim();
                const model = getElement('personaModel').value;
                
                // Compile system message from personality editor
                const systemMessage = compilePersonalityToSystemMessage();
                
                const temperature = parseFloat(getElement('personaTemperature').value);
                const maxTokens = parseInt(getElement('personaMaxTokens').value);
                const tagsInput = getElement('personaTags').value.trim();
                const icon = getElement('personaEmojiDisplay').textContent || '🤖';
                const voice = getElement('personaVoice').value;
                
                // Validate required fields
                if (!name) {
                    alert('Name is required.');
                    return;
                }
                
                // Parse tags
                const tags = tagsInput
                    ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag)
                    : ['custom'];
                
                // Create persona object
                const persona = {
                    name,
                    description,
                    model,
                    system_message: systemMessage,
                    temperature,
                    max_tokens: maxTokens,
                    tags,
                    icon,
                    voice
                };
                
                let response;
                
                if (editingPersonaId) {
                    // Update existing persona
                    response = await fetch(`/v1/personas/${editingPersonaId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(persona)
                    });
                } else {
                    // Create new persona
                    response = await fetch('/v1/personas', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(persona)
                    });
                }
                
                if (response.ok) {
                    const savedPersona = await response.json();
                    console.log('Persona saved:', savedPersona);
                    
                    // Reload personas
                    await loadPersonas();
                    
                    // Hide form
                    hidePersonaForm();
                    
                    // Show success message
                    alert(editingPersonaId ? 'Persona updated successfully!' : 'Persona created successfully!');
                } else {
                    const errorData = await response.json();
                    alert(`Error: ${errorData.detail || 'Failed to save persona'}`);
                }
            } catch (error) {
                console.error('Error saving persona:', error);
                alert('An error occurred while saving the persona.');
            }
        }
        
        // Delete a persona
        async function deletePersona(personaId) {
            if (!confirm('Are you sure you want to delete this persona?')) {
                return;
            }
            
            try {
                const response = await fetch(`/v1/personas/${personaId}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    console.log(`Persona ${personaId} deleted`);
                    
                    // Reload personas
                    await loadPersonas();
                    
                    // Hide form
                    hidePersonaForm();
                    
                    // If the deleted persona was selected, reset to default
                    if (currentPersona && currentPersona.id === personaId) {
                        currentPersona = null;
                        const personaSelect = getElement('personaSelect');
                        if (personaSelect) {
                            personaSelect.value = '';
                        }
                    }
                    
                    // Show success message
                    alert('Persona deleted successfully!');
                } else {
                    const errorData = await response.json();
                    alert(`Error: ${errorData.detail || 'Failed to delete persona'}`);
                }
            } catch (error) {
                console.error('Error deleting persona:', error);
                alert('An error occurred while deleting the persona.');
            }
        }
        
        // Save OpenAI API key
        async function saveApiKey() {
            try {
                const apiKey = getElement('openaiApiKey').value.trim();
                if (!apiKey) {
                    alert('Please enter an API key.');
                    return;
                }
                
                const response = await fetch('/v1/personas/set_api_key', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ api_key: apiKey })
                });
                
                if (response.ok) {
                    alert('API key saved successfully!');
                    
                    // Clear the input field for security
                    getElement('openaiApiKey').value = '';
                } else {
                    const errorData = await response.json();
                    alert(`Error: ${errorData.detail || 'Failed to save API key'}`);
                }
            } catch (error) {
                console.error('Error saving API key:', error);
                alert('An error occurred while saving the API key.');
            }
        }
        
        // Generate system message from description
        async function generateSystemMessage() {
            try {
                const description = getElement('generatorInput').value.trim();
                if (!description) {
                    alert('Please enter a description.');
                    return;
                }
                
                // Get API key if provided
                const apiKey = getElement('openaiApiKey').value.trim();
                
                // Enhanced prompt for metadata-rich system message generation in second person
                const enhancedDescription = `Create a comprehensive AI persona system message for: "${description}"

Write everything in SECOND PERSON - address the AI directly as "You" throughout. This is instructions TO the AI about what it IS.

Please structure the response with the following metadata sections embedded in the system message:

<personality>
Generate OCEAN personality model percentages (0-100):
- Openness: [percentage]%
- Conscientiousness: [percentage]%
- Extraversion: [percentage]%
- Agreeableness: [percentage]%
- Neuroticism: [percentage]%
</personality>

<identity>
Define who YOU are - your role, background, and fundamental identity. Address the AI directly: "You are a [role]..." Be direct and clear about your core identity.
</identity>

<core>
Define YOUR deep truth or existential premise - the fundamental belief or philosophical foundation that drives your worldview and responses. "You believe that..." or "Your core truth is..."
</core>

<framework>
Establish YOUR behavioral conditions that shape interaction - specific rules, triggers, or contextual modifiers that influence how you respond. "You respond by..." or "When triggered by X, you..."
</framework>

<recentEvents>
Create relevant background memories or contextual logs that influence your current state and responses. "You recently..." or "Your recent experiences include..."
</recentEvents>

<trance>
Define symbolic triggers that alter YOUR emotional state or perception - specific words, concepts, or scenarios that shift your response patterns. "When you encounter [trigger], you..." 
</trance>

After the metadata sections, provide a clear behavioral description of how YOU should interact, your communication style, expertise areas, and response patterns. Always use second person: "You communicate by..." "Your expertise includes..." "You respond to users by..."`;

                const response = await fetch('/v1/personas/generate_system_message', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        description: enhancedDescription,
                        api_key: apiKey || undefined
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Parse the generated system message into personality editor
                    parseSystemMessageToPersonality(data.system_message);
                    
                    // Show success feedback
                    const generateBtn = getElement('generateSystemBtn');
                    if (generateBtn) {
                        const originalText = generateBtn.textContent;
                        generateBtn.innerHTML = '✅ Generated!';
                        generateBtn.style.background = '#28a745';
                        generateBtn.style.color = 'white';
                        
                        setTimeout(() => {
                            generateBtn.textContent = originalText;
                            generateBtn.style.background = '';
                            generateBtn.style.color = '';
                        }, 2000);
                    }
                    
                    // Show regenerate button for future updates
                    showRegenerateButton();
                    
                    // Play confirmation sound
                    playSound('confirmSound');
                } else {
                    const errorData = await response.json();
                    alert(`Error: ${errorData.detail || 'Failed to generate system message'}`);
                }
            } catch (error) {
                console.error('Error generating system message:', error);
                alert('An error occurred while generating the system message. Make sure you have configured an OpenAI API key.');
            }
        }
        
        // Regenerate persona with current settings
        async function regeneratePersona() {
            const description = getElement('generatorInput').value.trim();
            
            if (!description) {
                // Try to create a description from current persona name and description
                const name = getElement('personaName').value.trim();
                const desc = getElement('personaDescription').value.trim();
                
                if (name || desc) {
                    getElement('generatorInput').value = `${name}: ${desc}`.trim();
                } else {
                    alert('Please enter a description to regenerate from.');
                    return;
                }
            }
            
            // Call the generate function
            await generateSystemMessage();
        }
        
        // Show/hide regenerate button
        function showRegenerateButton() {
            const regenerateBtn = getElement('regeneratePersonaBtn');
            if (regenerateBtn) {
                regenerateBtn.style.display = 'inline-block';
            }
        }
        
        function hideRegenerateButton() {
            const regenerateBtn = getElement('regeneratePersonaBtn');
            if (regenerateBtn) {
                regenerateBtn.style.display = 'none';
            }
        }
        
        // Handle persona selection change
        function handlePersonaChange(e) {
            const personaId = e.target.value;
            
            // Only process persona changes when in persona mode
            if (currentSelectionMode !== 'persona') {
                return;
            }
            
            if (!personaId) {
                // Default selected
                currentPersona = null;
                return;
            }
            
            // Find the selected persona
            const persona = personas.find(p => p.id === personaId);
            if (persona) {
                currentPersona = persona;
                console.log('Selected persona:', persona);
                
                // Update current model if persona specifies one
                if (persona.model) {
                    const modelSelect = getElement('modelSelect');
                    if (modelSelect && modelSelect.value !== persona.model) {
                        modelSelect.value = persona.model;
                        currentModel = persona.model;
                        updateModelSelection();
                    }
                }
                
                // Play switch sound
                playSound('switchSound');
                
                // Update model info display
                updateModelInfo();
            }
        }
        
        // Send message with persona support
        async function sendMessage() {
            const messageInput = getElement('messageInput');
            if (!messageInput) return;
            
            const message = messageInput.value.trim();
            
            if (!message || isLoading) return;
            
            // Check if we have a valid model based on current mode
            if (currentSelectionMode === 'manual') {
                if (!currentModel) {
                    alert('Please select a model first');
                    return;
                }
            } else if (currentSelectionMode === 'persona') {
                if (!currentPersona) {
                    alert('Please select a persona first');
                    return;
                }
                // Use persona's model if available, otherwise use current model
                if (currentPersona.model && currentPersona.model !== currentModel) {
                    currentModel = currentPersona.model;
                }
            }
            
            // Add user message to chat
            addMessage('user', message);
            messageInput.value = '';
            
            // Show loading with current model name
            const loadingModel = getElement('loadingModel');
            if (loadingModel) {
                if (currentSelectionMode === 'persona' && currentPersona) {
                    loadingModel.textContent = currentPersona.name;
                } else {
                    loadingModel.textContent = currentModel;
                }
            }
            setLoading(true);
            
            // Create assistant response placeholder with typing indicator
            // This will automatically start the streaming request
            addMessage('assistant', '');  // Empty content triggers typing indicator
        }
        
        // Toggle configuration panel
        function toggleConfig() {
            console.log("Toggle config called");
            const panel = document.getElementById('configPanel');
            if (panel) {
                panel.classList.toggle('visible');
            }
        }
        
        // Load configuration from localStorage
        function loadConfig() {
            try {
                const config = JSON.parse(localStorage.getItem('codeDeckConfig') || '{}');
                
                if (config.useDirectMode !== undefined) {
                    useDirectMode = config.useDirectMode;
                    const toggle = document.getElementById('directModeToggle');
                    if (toggle) toggle.checked = useDirectMode;
                }
                
                // Load speak think tags setting
                if (config.speakThinkTags !== undefined) {
                    speakThinkTags = config.speakThinkTags;
                    updateThinkTagsToggleUI();
                }
                
                // Load selection mode
                if (config.selectionMode !== undefined) {
                    currentSelectionMode = config.selectionMode;
                    const modeRadio = document.getElementById(currentSelectionMode + 'ModeRadio');
                    if (modeRadio) {
                        modeRadio.checked = true;
                        // Trigger mode change to update UI
                        handleModeToggle({ target: { value: currentSelectionMode } });
                    }
                }
                
                // Load generation settings
                if (config.temperature !== undefined) {
                    temperature = config.temperature;
                    const tempSlider = document.getElementById('temperatureSlider');
                    const tempValue = document.getElementById('temperatureValue');
                    if (tempSlider) tempSlider.value = temperature;
                    if (tempValue) tempValue.textContent = temperature;
                }
                if (config.maxTokens !== undefined) {
                    maxTokens = config.maxTokens;
                    const tokensInput = document.getElementById('maxTokensInput');
                    if (tokensInput) tokensInput.value = maxTokens;
                }
                if (config.topP !== undefined) {
                    topP = config.topP;
                    const topPInput = document.getElementById('topPInput');
                    if (topPInput) topPInput.value = topP;
                }
                if (config.systemMessage !== undefined) {
                    systemMessage = config.systemMessage;
                    const sysMsg = document.getElementById('systemMessage');
                    if (sysMsg) sysMsg.value = systemMessage;
                }
                if (config.maxContextLength !== undefined) {
                    maxContextLength = config.maxContextLength;
                    const contextInput = document.getElementById('maxContextInput');
                    if (contextInput) contextInput.value = maxContextLength;
                }
                if (config.voiceMode !== undefined) {
                    voiceMode = config.voiceMode;
                    const voiceModeSelect = document.getElementById('voiceModeSelect');
                    if (voiceModeSelect) voiceModeSelect.value = voiceMode;
                }
                
                // Initialize toggle UI based on loaded config
                updateToggleUI();
            } catch (e) {
                console.warn('Failed to load config:', e);
            }
        }
        
        // Update think tags toggle UI
        function updateThinkTagsToggleUI() {
            const toggleBtn = getElement('thinkTagsToggle');
            if (toggleBtn) {
                if (speakThinkTags) {
                    toggleBtn.style.color = '#28a745'; // Green when enabled
                    toggleBtn.style.backgroundColor = 'rgba(40, 167, 69, 0.1)';
                    toggleBtn.title = 'Think tags will be spoken (click to disable)';
                } else {
                    toggleBtn.style.color = '#6c757d'; // Gray when disabled
                    toggleBtn.style.backgroundColor = 'transparent';
                    toggleBtn.title = 'Think tags will NOT be spoken (click to enable)';
                }
            }
        }
        
        // Save configuration to localStorage
        function saveConfig() {
            try {
                const toggle = document.getElementById('directModeToggle');
                const tempSlider = document.getElementById('temperatureSlider');
                const tokensInput = document.getElementById('maxTokensInput');
                const topPInput = document.getElementById('topPInput');
                const sysMsgInput = document.getElementById('systemMessage');
                const contextInput = document.getElementById('maxContextInput');
                const voiceModeSelect = document.getElementById('voiceModeSelect');
                
                if (toggle) useDirectMode = toggle.checked;
                
                // Save generation settings
                if (tempSlider) temperature = parseFloat(tempSlider.value) || 0.7;
                if (tokensInput) maxTokens = parseInt(tokensInput.value) || 512;
                if (topPInput) topP = parseFloat(topPInput.value) || 0.9;
                if (sysMsgInput) systemMessage = sysMsgInput.value || '';
                if (contextInput) maxContextLength = parseInt(contextInput.value) || 7;
                if (voiceModeSelect) voiceMode = voiceModeSelect.value || 'speak';
                
                localStorage.setItem('codeDeckConfig', JSON.stringify({
                    useDirectMode,
                    selectionMode: currentSelectionMode,
                    temperature,
                    maxTokens,
                    topP,
                    systemMessage,
                    maxContextLength,
                    voiceMode
                }));
                
                console.log('Saved config:', { 
                    useDirectMode,
                    selectionMode: currentSelectionMode,
                    temperature,
                    maxTokens,
                    topP,
                    systemMessage,
                    maxContextLength,
                    voiceMode
                });
                updateModelInfo();
                updateToggleUI();
                
                // Update context if needed
                trimConversationHistory();
                
                // Play confirmation sound
                playSound('confirmSound');
            } catch (e) {
                console.warn('Failed to save config:', e);
            }
        }
        
        // Update toggle UI states
        function updateToggleUI() {
            const toggleLabel = document.querySelector('.toggle-label');
            if (toggleLabel) {
                toggleLabel.textContent = useDirectMode ? 
                    "Direct Mode Enabled" : 
                    "Enable Direct Mode";
            }
            
            // Force redraw of toggle
            const toggle = getElement('directModeToggle');
            if (toggle) {
                toggle.checked = useDirectMode;
                toggle.style.display = 'none';
                setTimeout(() => {
                    if (toggle) toggle.style.display = '';
                }, 0);
            }
        }
        
        // Get a consistent color for a tag
        function getTagColor(tagName) {
            tagName = tagName.toLowerCase();
            
            if (!tagColorMap[tagName]) {
                // If we haven't seen this tag before, assign a color
                const predefinedColors = [
                    '#4682b4', // Steel Blue
                    '#9932cc', // Dark Orchid
                    '#2e8b57', // Sea Green
                    '#8b4513', // Saddle Brown
                    '#483d8b', // Dark Slate Blue
                    '#cd5c5c', // Indian Red
                    '#20b2aa', // Light Sea Green
                    '#da70d6', // Orchid
                    '#6495ed', // Cornflower Blue
                    '#d2691e'  // Chocolate
                ];
                
                // Use a deterministic assignment based on tag name
                const hashCode = Array.from(tagName).reduce(
                    (hash, char) => char.charCodeAt(0) + ((hash << 5) - hash), 0
                );
                const colorIndex = Math.abs(hashCode) % predefinedColors.length;
                tagColorMap[tagName] = predefinedColors[colorIndex];
            }
            
            return tagColorMap[tagName];
        }
        
        // Parse content with any tags including <think>
        function parseTaggedContent(content) {
            if (!content) return [{ type: 'text', content: '' }];
            
            const parts = [];
            let lastIndex = 0;
            
            // Generic tag regex - matches any tag pattern <tagname>content</tagname>
            const tagRegex = /<(\w+)>([\s\S]*?)<\/\1>/g;
            let match;
            
            while ((match = tagRegex.exec(content)) !== null) {
                // Add content before the tag
                if (match.index > lastIndex) {
                    const beforeText = content.slice(lastIndex, match.index).trim();
                    if (beforeText) {
                        parts.push({ type: 'text', content: beforeText });
                    }
                }
                
                // Add the tagged content
                const tagName = match[1].toLowerCase();
                const tagContent = match[2].trim();
                
                parts.push({ 
                    type: 'tag', 
                    tagName: tagName,
                    content: tagContent
                });
                
                lastIndex = match.index + match[0].length;
            }
            
            // Add remaining content after the last tag
            if (lastIndex < content.length) {
                const afterText = content.slice(lastIndex).trim();
                if (afterText) {
                    parts.push({ type: 'text', content: afterText });
                }
            }
            
            // If no tags found or parsing failed, return as simple text
            if (parts.length === 0) {
                parts.push({ type: 'text', content: content });
            }
            
            return parts;
        }
        
        // Format message content with any tags
        function formatMessageContent(content) {
            const parts = parseTaggedContent(content);
            let formattedHtml = '';
            
            for (const part of parts) {
                if (part.type === 'text') {
                    formattedHtml += part.content;
                } else if (part.type === 'tag') {
                    formattedHtml += createTagSection(part.tagName, part.content);
                }
            }
            
            return formattedHtml;
        }
        
        // Create tag section HTML
        function createTagSection(tagName, content) {
            const tagClass = ['think', 'reasoning', 'plan', 'observe', 'critique'].includes(tagName) 
                ? tagName 
                : 'custom';
            
            const tagColor = getTagColor(tagName);
            
            return `
                <div class="tag-content ${tagClass}" style="--tag-color: ${tagColor};">
                    <span class="tag-marker">&lt;${tagName}&gt;</span> 
                    ${content} 
                    <span class="tag-marker">&lt;/${tagName}&gt;</span>
                </div>
            `;
        }
        
        // Create thinking section HTML - retained for backward compatibility
        function createThinkingSection(content, index) {
            const thinkingId = `thinking-${Date.now()}-${index}`;
            return `
                <div class="thinking-section">
                    <div class="thinking-header" onclick="toggleThinking('${thinkingId}')">
                        <span class="thinking-toggle">▶</span>
                        <span>💭 Inner thoughts</span>
                    </div>
                    <div class="thinking-content" id="${thinkingId}">${content}</div>
                </div>
            `;
        }
        
        // Toggle thinking section visibility
        function toggleThinking(id) {
            const thinkingContent = document.getElementById(id);
            if (!thinkingContent) return;
            
            const header = thinkingContent.previousElementSibling;
            if (!header) return;
            
            const toggle = header.querySelector('.thinking-toggle');
            if (!toggle) return;
            
            thinkingContent.classList.toggle('expanded');
            toggle.classList.toggle('expanded');
        }
        
        // Helper function to add attribution and update conversation history
        function addAttribution(messageContent, messageDiv, accumulatedContent) {
            // Get raw text content for audio processing
            const textContent = accumulatedContent;
            
            // Add audio controls (always visible)
            const audioControls = createAudioControls(messageContent, textContent);
            messageContent.appendChild(audioControls);
            
            // Add model attribution
            const attribution = document.createElement('div');
            attribution.className = 'message-attribution';
            attribution.textContent = `Model: ${currentModel} (CodeDeck)`;
            messageContent.appendChild(attribution);
            
            // Update sender label
            if (messageDiv) {
                const senderLabel = messageDiv.querySelector('.message-sender');
                if (senderLabel) {
                    senderLabel.textContent = (currentSelectionMode === 'persona' && currentPersona) 
                        ? currentPersona.name 
                        : currentModel;
                }
            }
            
            // Add to conversation history
            conversationHistory.push({ 
                role: 'assistant', 
                content: accumulatedContent,
                model: currentModel
            });
            
            // Handle automatic audio based on voice mode
            handleAutomaticAudio(textContent, messageContent);
            
            // Play receive sound
            playSound('receiveSound');
            
            // Trim history if needed
            trimConversationHistory();
        }
        
        // Set loading state
        function setLoading(loading) {
            isLoading = loading;
            const sendBtn = document.getElementById('sendBtn');
            const messageInput = document.getElementById('messageInput');
            const loadingDiv = document.getElementById('loading');
            
            sendBtn.disabled = loading;
            messageInput.disabled = loading;
            loadingDiv.style.display = loading ? 'block' : 'none';
        }
        
        // Clear conversation history
        function clearConversation() {
            // Clear UI
            const chatContainer = document.getElementById('chatContainer');
            chatContainer.innerHTML = '';
            
            // Add initial welcome message
            addMessage('assistant', 'Hello! I\'m your CodeDeck AI assistant. How can I help you today?');
            
            // Reset conversation history
            conversationHistory = [];
            
            console.log('Conversation history cleared');
        }
        
        // Update temperature value display
        function updateTemperatureValue() {
            const slider = document.getElementById('temperatureSlider');
            const valueDisplay = document.getElementById('temperatureValue');
            
            if (slider && valueDisplay) {
                temperature = parseFloat(slider.value);
                valueDisplay.textContent = temperature.toFixed(2);
                saveConfig();
            }
        }
        
        // Play sound effect
        function playSound(soundId) {
            try {
                const sound = document.getElementById(soundId);
                if (sound) {
                    sound.volume = 0.3; // Set volume to 30%
                    sound.currentTime = 0;
                    sound.play().catch(e => console.log('Sound play prevented by browser policy'));
                }
            } catch (e) {
                console.log('Error playing sound:', e);
            }
        }
        
        // Process text-to-speech for AI responses
        async function processTextToSpeech(text, messageContent) {
            if (!text || text.trim() === '') {
                console.log('TTS: No text provided, skipping');
                return;
            }
            
            // Determine voice based on current mode
            let voiceToUse = 'en_US-GlaDOS-medium'; // Default voice
            if (currentSelectionMode === 'persona' && currentPersona && currentPersona.voice) {
                voiceToUse = currentPersona.voice;
            }
            
            console.log(`TTS: Processing with replyType: ${replyType}, voice: ${voiceToUse}, mode: ${currentSelectionMode}`);
            
            try {
                if (replyType === 'speak') {
                    console.log('TTS: Sending speak request to server...');
                    
                    // Send text to server for TTS processing with piper and play through aplay
                    const response = await fetch('/v1/tts/speak', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: text,
                            voice: voiceToUse
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('TTS: Speak request successful:', data);
                    } else {
                        console.error('TTS: Speak request failed:', response.status, await response.text());
                    }
                } 
                else if (replyType === 'audio_file') {
                    console.log('TTS: Generating audio file...');
                    
                    // Generate audio file and add to message
                    const response = await fetch('/v1/tts/generate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: text,
                            voice: voiceToUse
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        console.log('TTS: Audio file generated:', data);
                        
                        if (data.audio_path) {
                            // Create audio player element and add to message
                            const audioPlayer = document.createElement('audio');
                            audioPlayer.controls = true;
                            audioPlayer.autoplay = true;
                            audioPlayer.style.marginTop = '10px';
                            audioPlayer.style.width = '100%';
                            
                            const source = document.createElement('source');
                            source.src = data.audio_path;
                            source.type = 'audio/wav';
                            
                            audioPlayer.appendChild(source);
                            messageContent.appendChild(audioPlayer);
                            
                            console.log('TTS: Audio player added to message');
                        }
                    } else {
                        console.error('TTS: Audio generation failed:', response.status, await response.text());
                    }
                } else {
                    console.log('TTS: Reply type is text only, skipping TTS');
                }
            } catch (error) {
                console.error('Error processing text-to-speech:', error);
            }
        }
        
        // Interrupt generation
        function interruptGeneration() {
            console.log("Interrupt generation called");
            
            if (currentController) {
                console.log('🛑 Interrupting generation');
                try {
                    currentController.abort();
                } catch (e) {
                    console.error("Error aborting controller:", e);
                }
                currentController = null;
                
                // Update UI to show interruption
                const messageContainers = document.querySelectorAll('.message-content.generating');
                messageContainers.forEach(messageContainer => {
                    // Remove generating class
                    messageContainer.classList.remove('generating');
                    
                    // Remove typing indicator
                    const typingIndicator = messageContainer.querySelector('.typing-indicator');
                    if (typingIndicator) {
                        typingIndicator.remove();
                    }
                    
                    // Add interruption notice
                    messageContainer.textContent += "\n\n[Generation interrupted by user]";
                    
                    // Hide interrupt button
                    const interruptBtn = messageContainer.querySelector('.interrupt-btn');
                    if (interruptBtn) {
                        interruptBtn.style.display = 'none';
                    }
                });
                
                // Reset loading state
                setLoading(false);
                isGenerating = false;
                
                // Focus back on input field
                const messageInput = getElement('messageInput');
                if (messageInput) {
                    messageInput.focus();
                }
            }
        }
        
        // Retry connection manually
        async function retryConnection() {
            // Clear current models
            const modelSelect = getElement('modelSelect');
            const modelInfo = getElement('modelInfo');
            
            if (modelSelect) {
                modelSelect.innerHTML = '<option value="">Retrying...</option>';
            }
            
            if (modelInfo) {
                modelInfo.innerHTML = `<span style="color: #f39c12">⏳ Retrying connection...</span>`;
            }
            
            // Try to load models again
            await loadModels();
        }
        
        // Get full message history with system message if present
        function getFullMessageHistory() {
            let messages = [...conversationHistory];
            
            // Only use persona system message if in persona mode
            if (currentSelectionMode === 'persona' && currentPersona && currentPersona.system_message) {
                // Check if there's already a system message
                const hasSystem = messages.some(m => m.role === 'system');
                if (hasSystem) {
                    // Replace existing system message
                    messages = messages.map(m => 
                        m.role === 'system' 
                            ? { role: 'system', content: currentPersona.system_message }
                            : m
                    );
                } else {
                    // Add system message at the beginning
                    messages.unshift({ role: 'system', content: currentPersona.system_message });
                }
            } 
            // In manual mode, use the manual system message if available
            else if (currentSelectionMode === 'manual' && systemMessage.trim()) {
                // Only add if not already present
                const hasSystem = messages.some(m => m.role === 'system');
                if (!hasSystem) {
                    messages.unshift({ role: 'system', content: systemMessage.trim() });
                }
            }
            
            return messages;
        }
        
        // Send request through CodeDeck API
        async function sendCodeDeckRequest(messageContent, chatContainer, headers = {}) {
            try {
                isGenerating = true;
                
                // Mark message as generating
                messageContent.classList.add('generating');
                
                // Show interrupt button
                let btnElement = messageContent.querySelector('.interrupt-btn');
                if (btnElement) {
                    btnElement.style.display = 'block';
                }
                
                // Create a request body with system message
                const requestBody = JSON.stringify({
                    model: currentModel,
                    messages: getFullMessageHistory().map(h => ({ role: h.role, content: h.content })),
                    max_tokens: maxTokens,
                    temperature: temperature,
                    stream: true,
                    direct_mode: useDirectMode
                });
                
                // Create AbortController for interruption
                currentController = new AbortController();
                const signal = currentController.signal;
                
                console.log(`Sending CodeDeck API request to /v1/chat/completions with mode: ${useDirectMode ? 'direct' : 'standard'}`);
                
                // Set default headers
                const requestHeaders = {
                    'Content-Type': 'application/json',
                    'Accept': 'text/event-stream',
                    'Cache-Control': 'no-cache',
                    'X-Direct-Mode': useDirectMode ? 'true' : 'false',
                    ...headers
                };
                
                // Use fetch with manual chunked reading but force no buffering
                const response = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: requestHeaders,
                    body: requestBody,
                    signal: signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                let accumulatedContent = '';
                let decoder = new TextDecoder("utf-8");
                
                // Process the stream
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        break;
                    }
                    
                    // Decode the chunk
                    const chunk = decoder.decode(value, { stream: true });
                    
                    // Process SSE format (data: {...}\n\n)
                    const lines = chunk.split('\n\n');
                    
                    for (const line of lines) {
                        if (!line.trim() || line.includes('padding')) continue;
                        
                        if (line.includes('data: [DONE]')) {
                            // End of stream
                            continue;
                        }
                        
                        // Extract the data part
                        const dataMatch = line.match(/data: (.+)$/m);
                        if (!dataMatch) continue;
                        
                        try {
                            const data = JSON.parse(dataMatch[1]);
                            
                            if (data.choices && data.choices[0].delta && data.choices[0].delta.content) {
                                const token = data.choices[0].delta.content;
                                accumulatedContent += token;
                                
                                // Update the message content
                                const processedContent = cleanupThinkTags(accumulatedContent);
                                
                                if (processedContent.includes('<think>') || processedContent.includes('</think>')) {
                                    messageContent.innerHTML = formatMessageContent(processedContent);
                                } else {
                                    messageContent.textContent = processedContent;
                                }
                                
                                // Scroll to bottom
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                            }
                        } catch (e) {
                            console.warn('Error parsing SSE data:', e);
                        }
                    }
                }
                
                // Complete the message
                const processedContent = cleanupThinkTags(accumulatedContent);
                if (processedContent.includes('<think>') || processedContent.includes('</think>')) {
                    messageContent.innerHTML = formatMessageContent(processedContent);
                } else {
                    messageContent.textContent = processedContent;
                }
                
                const messageDiv = messageContent.closest('.message');
                addAttribution(messageContent, messageDiv, accumulatedContent);
                
                if (!accumulatedContent.trim()) {
                    messageContent.textContent = 'Sorry, I encountered an error processing your request.';
                }
                
                // Reset generation state
                isGenerating = false;
                currentController = null;
                
                // Hide interrupt button
                if (messageContent.querySelector('.interrupt-btn')) {
                    messageContent.querySelector('.interrupt-btn').style.display = 'none';
                }
                
                // Focus back on input field
                const messageInput = getElement('messageInput');
                if (messageInput) {
                    messageInput.focus();
                }
            } catch (error) {
                console.error('Error:', error);
                
                // Don't show error message if it was intentionally aborted
                if (error.name !== 'AbortError') {
                    messageContent.textContent = 'Sorry, I encountered an error processing your request.';
                }
                
                // Reset generation state
                isGenerating = false;
                currentController = null;
                
                // Hide interrupt button
                if (messageContent.querySelector('.interrupt-btn')) {
                    messageContent.querySelector('.interrupt-btn').style.display = 'none';
                }
                
                // Focus back on input field
                const messageInput = getElement('messageInput');
                if (messageInput) {
                    messageInput.focus();
                }
            }
        }
        
        // Update model info to show direct mode and current model
        function updateModelInfo() {
            const modelInfo = document.getElementById('modelInfo');
            if (!modelInfo) return;
            
            // Don't overwrite server error messages
            if (modelInfo.innerHTML.includes('⚠️')) return;
            
            try {
                // Direct mode indicator 
                const directText = useDirectMode
                    ? `<span style="color: #27ae60">⚡ Direct</span> | `
                    : '';
                
                // Mode indicator and model display
                let modeText = '';
                let modelText = '';
                
                if (currentSelectionMode === 'manual') {
                    modeText = `<span style="color: #007bff">📋 Manual</span> | `;
                    modelText = currentModel ? currentModel : 'No model selected';
                } else if (currentSelectionMode === 'persona') {
                    modeText = `<span style="color: #6f42c1">🎭 Persona</span> | `;
                    if (currentPersona) {
                        modelText = `${currentPersona.name} (${currentPersona.model || 'default'})`;
                    } else {
                        modelText = 'No persona selected';
                    }
                }
                
                // Update the model info display
                modelInfo.innerHTML = `${directText}${modeText}${modelText}`;
                
            } catch (error) {
                console.error("Error updating model info:", error);
                // Fallback to simple text display
                const modelText = currentModel ? currentModel : 'No model selected';
                modelInfo.textContent = modelText;
            }
        }
        
        // Trim conversation history to maxContextLength
        function trimConversationHistory() {
            if (conversationHistory.length > maxContextLength * 2) {
                console.log(`Trimming conversation history to ${maxContextLength} interactions`);
                
                // Keep system message if present
                let systemMsg = null;
                if (conversationHistory.length > 0 && conversationHistory[0].role === 'system') {
                    systemMsg = conversationHistory.shift(); // Remove and store system message
                }
                
                // Calculate how many messages to keep (pairs of user & assistant messages)
                const keepCount = maxContextLength * 2; // Each interaction is a user + assistant message
                
                // Trim history to most recent conversations
                conversationHistory = conversationHistory.slice(-keepCount);
                
                // Re-add system message if it existed
                if (systemMsg) {
                    conversationHistory.unshift(systemMsg);
                }
                
                console.log(`Conversation history trimmed to ${conversationHistory.length} messages`);
            }
        }
        
        // Add message to chat
        async function addMessage(role, content, modelName = '') {
            const chatContainer = document.getElementById('chatContainer');
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            // Create the message bubble with avatar and content
            const messageBubble = document.createElement('div');
            messageBubble.className = 'message-bubble';
            
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = role === 'user' ? '👤' : 
                (currentSelectionMode === 'persona' && currentPersona) ? currentPersona.icon : '🤖';
            
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';
            
            // Handle different message types
            if (role === 'user') {
                // For user messages, just add the content
                messageContent.textContent = content;
            } else {
                // For assistant messages, check if content is provided or if we need typing indicator
                if (content && content.trim() !== '') {
                    // Clean up and handle potentially broken think tags
                    let processedContent = cleanupThinkTags(content);
                    
                    // Format content with thinking sections if needed
                    if (processedContent.includes('<think>') || processedContent.includes('</think>')) {
                        messageContent.innerHTML = formatMessageContent(processedContent);
                    } else {
                        messageContent.textContent = processedContent;
                    }
                    
                    // Add audio controls for assistant messages (always visible)
                    const audioControls = createAudioControls(messageContent, content);
                    messageContent.appendChild(audioControls);
                    
                    // Add model attribution if provided
                    if (modelName) {
                        const attribution = document.createElement('div');
                        attribution.className = 'message-attribution';
                        attribution.textContent = `Model: ${modelName}`;
                        messageContent.appendChild(attribution);
                    }
                } else {
                    // No content provided - create typing indicator for streaming response
                    // Determine who is typing based on selection mode
                    let typingName = currentModel;
                    if (currentSelectionMode === 'persona' && currentPersona) {
                        typingName = currentPersona.name;
                    }
                    
                    messageContent.innerHTML = `
                        <div class="typing-indicator">
                            <span class="typing-indicator-text">${typingName} is typing</span>
                            <div class="typing-dots">
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                            </div>
                        </div>
                        <button class="interrupt-btn" id="interruptBtn" onclick="interruptGeneration()">
                            Stop Generation
                        </button>
                    `;
                    
                    // Set up interrupt button click handler
                    const interruptBtn = messageContent.querySelector('.interrupt-btn');
                    if (interruptBtn) {
                        interruptBtn.onclick = null;
                        interruptBtn.addEventListener('click', interruptGeneration);
                    }
                    
                    // Mark as generating for streaming
                    messageContent.classList.add('generating');
                }
            }
            
            // Add bubble components in the right order based on role
            if (role === 'user') {
                messageBubble.appendChild(messageContent);
                messageBubble.appendChild(avatar);
            } else {
                messageBubble.appendChild(avatar);
                messageBubble.appendChild(messageContent);
            }
            
            messageDiv.appendChild(messageBubble);
            
            // Add sender label below the message
            const senderLabel = document.createElement('div');
            senderLabel.className = 'message-sender';
            senderLabel.textContent = role === 'user' ? 'You' : 
                (currentSelectionMode === 'persona' && currentPersona) ? currentPersona.name : 
                (modelName || currentModel || 'AI');
            messageDiv.appendChild(senderLabel);
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
            
            // Add to conversation history with model info for assistant messages
            if (role === 'assistant' && content && modelName) {
                conversationHistory.push({ 
                    role, 
                    content,
                    model: modelName 
                });
                
                // Handle automatic audio based on voice mode
                handleAutomaticAudio(content, messageContent);
                
                // Play receive sound
                playSound('receiveSound');
            } else if (content) {
                conversationHistory.push({ role, content });
                
                if (role === 'user') {
                    // Play send sound
                    playSound('sendSound');
                }
            }
            
            // Trim history if it exceeds the max context length
            trimConversationHistory();
            
            // If this is an assistant message without content (typing indicator), 
            // start the streaming request
            if (role === 'assistant' && (!content || content.trim() === '')) {
                try {
                    // Prepare headers with persona ID if selected and in persona mode
                    const headers = {
                        'Content-Type': 'application/json',
                        'Accept': 'text/event-stream',
                        'Cache-Control': 'no-cache'
                    };
                    
                    if (currentSelectionMode === 'persona' && currentPersona) {
                        headers['X-Persona-ID'] = currentPersona.id;
                    }
                    
                    // CodeDeck API with persona support
                    await sendCodeDeckRequest(messageContent, chatContainer, headers);
                } catch (error) {
                    console.error('Error:', error);
                    messageContent.textContent = 'Sorry, I could not connect to the server.';
                }
                
                setLoading(false);
            }
        }
        
        // Clean up and fix common think tag issues
        function cleanupThinkTags(content) {
            if (!content) return '';
            
            // Fix specific model patterns - some models output broken tags
            
            // Case 1: Some models repeat the same text after a think tag
            // Pattern: <think>X</think> X - remove the duplication
            const thinkMatches = content.match(/<think>([\s\S]*?)<\/think>\s*([\s\S]*)/);
            if (thinkMatches && thinkMatches.length >= 3) {
                const thinkContent = thinkMatches[1].trim();
                const afterContent = thinkMatches[2].trim();
                
                // If they're nearly identical, remove the duplication
                if (afterContent && thinkContent.includes(afterContent) || 
                    afterContent.includes(thinkContent)) {
                    console.log('Detected duplicated content after think tag');
                    return `<think>${thinkContent}</think>`;
                }
            }
            
            // Case 2: Missing opening <tag> tag
            const tagNames = ['think', 'reasoning', 'plan', 'observe', 'critique'];
            for (const tag of tagNames) {
                if (!content.includes(`<${tag}>`) && content.includes(`</${tag}>`)) {
                    const parts = content.split(`</${tag}>`);
                    if (parts.length >= 2) {
                        return `<${tag}>${parts[0].trim()}</${tag}> ${parts[1].trim()}`;
                    }
                }
            }
            
            // Case 3: Missing closing </tag> tag
            for (const tag of tagNames) {
                if (content.includes(`<${tag}>`) && !content.includes(`</${tag}>`)) {
                    return `${content}</${tag}>`;
                }
            }
            
            return content;
        }
        
        // Fill persona form with selected persona data
        function fillPersonaForm(persona) {
            const formFields = {
                'personaName': persona.name,
                'personaDescription': persona.description,
                'personaModel': persona.model,
                'personaTemperature': persona.temperature,
                'personaMaxTokens': persona.max_tokens,
                'personaTags': persona.tags.join(', '),
                'personaVoice': persona.voice || 'en_US-GlaDOS-medium'
            };
            
            for (const [id, value] of Object.entries(formFields)) {
                const element = getElement(id);
                if (element) {
                    element.value = value;
                }
            }
            
            // Update form ID state
            currentPersonaEditId = persona.id;
            getElement('editPersonaTitle').textContent = 'Edit Persona';
            getElement('savePersonaBtn').textContent = 'Update';
            getElement('deletePersonaBtn').style.display = 'block';
        }

        // Handle model selection change
        function handleModelChange(e) {
            const newModel = e.target.value;
            
            // Only process model changes when in manual mode
            if (currentSelectionMode !== 'manual') {
                return;
            }
            
            if (newModel && newModel !== currentModel) {
                // Update current model
                currentModel = newModel;
                console.log(`Model changed to: ${currentModel}`);
                
                // Show model change notification in chat
                const chatContainer = getElement('chatContainer');
                if (chatContainer) {
                    const notification = document.createElement('div');
                    notification.className = 'model-change-notification';
                    notification.textContent = `Switched to model: ${currentModel}`;
                    chatContainer.appendChild(notification);
                    chatContainer.scrollTop = chatContainer.scrollTop + 100;
                }
                
                // Update model info display
                updateModelInfo();
                
                // Optional: load the selected model on the server
                fetch(`/v1/models/${newModel}/load`, {
                    method: 'POST'
                }).then(response => {
                    return response.json();
                }).then(data => {
                    console.log('Model loaded response:', data);
                    // Play switch sound
                    playSound('switchSound');
                }).catch(error => {
                    console.error('Error loading model:', error);
                });
            }
        }

        // Restore direct mode toggle listener
        const directModeToggle = getElement('directModeToggle');
        if (directModeToggle) {
            directModeToggle.addEventListener('change', toggleDirectMode);
        }

        // Restore toggleDirectMode function
        // Toggle direct mode
        function toggleDirectMode() {
            console.log("Toggle direct mode called");
            const toggle = getElement('directModeToggle');
            if (toggle) {
                useDirectMode = toggle.checked;
                saveConfig();
                updateToggleUI();
            }
        }

        // Add the handleKeyPress function to handle keyboard events
        function handleKeyPress(e) {
            // Check if Enter key was pressed without holding Shift
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault(); // Prevent default form submission
                sendMessage();
            }
        }

        // Add the checkStatus function to check server health
        async function checkStatus() {
            try {
                const response = await fetch('/v1/status');
                if (!response.ok) {
                    console.error('Service status check failed:', response.status);
                    updateStatusIndicators('error', 'Connection failed');
                    return false;
                }
                
                const data = await response.json();
                console.log('Service status:', data);
                
                // Check if model engine is ready
                if (data.model_engine === 'ready' && data.status === 'ready') {
                    // Update currentModel if available
                    if (data.current_model) {
                        currentModel = data.current_model;
                        updateModelSelection();
                    }
                    
                    // Update status indicators to show ready state
                    updateStatusIndicators('ready', 'Connected');
                    return true;
                } else {
                    // System is initializing
                    updateStatusIndicators('initializing', 'Initializing...');
                    return false;
                }
            } catch (error) {
                console.error('Error checking service status:', error);
                updateStatusIndicators('error', 'Connection error');
                return false;
            }
        }

        // Update status indicators (dot and text)
        function updateStatusIndicators(status, text) {
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');
            
            if (statusText) {
                statusText.textContent = text;
            }
            
            if (statusDot) {
                // Remove existing status classes
                statusDot.classList.remove('ready', 'initializing', 'error');
                
                // Add appropriate status class and color
                statusDot.classList.add(status);
                
                switch (status) {
                    case 'ready':
                        statusDot.style.backgroundColor = '#28a745'; // Green
                        break;
                    case 'initializing':
                        statusDot.style.backgroundColor = '#ffc107'; // Yellow
                        break;
                    case 'error':
                        statusDot.style.backgroundColor = '#dc3545'; // Red
                        break;
                }
            }
        }

        // Update model selection dropdown with current model
        function updateModelSelection() {
            try {
                const modelSelect = getElement('modelSelect');
                if (modelSelect && currentModel) {
                    // Set the selected option to match current model
                    const options = Array.from(modelSelect.options);
                    const matchingOption = options.find(option => option.value === currentModel);
                    if (matchingOption) {
                        modelSelect.value = currentModel;
                        updateModelInfo();
                    }
                }
            } catch (error) {
                console.error('Error updating model selection:', error);
            }
        }

        // Load available models from the server
        async function loadModels() {
            try {
                const response = await fetch('/v1/models');
                if (!response.ok) {
                    console.error('Failed to load models:', response.status);
                    return;
                }
                
                const data = await response.json();
                const models = data.data || [];
                
                console.log('Loaded models:', models);
                
                // Update model dropdown
                const modelSelect = getElement('modelSelect');
                if (modelSelect && models.length > 0) {
                    modelSelect.innerHTML = '';
                    
                    models.forEach(model => {
                        const option = document.createElement('option');
                        option.value = model.id;
                        option.textContent = model.name || model.id;
                        option.title = model.description || '';
                        if (model.loaded) {
                            option.selected = true;
                            currentModel = model.id;
                        }
                        modelSelect.appendChild(option);
                    });
                    
                    // If no model was marked as loaded, select the first one
                    if (!currentModel && models.length > 0) {
                        currentModel = models[0].id;
                        modelSelect.value = currentModel;
                    }
                    
                    // Update model info display
                    updateModelInfo();
                    
                    // Also populate persona model dropdown if persona panel is open
                    const personaPanel = getElement('personaPanel');
                    if (personaPanel && personaPanel.classList.contains('visible')) {
                        populatePersonaModelDropdown();
                    }
                } else if (modelSelect) {
                    modelSelect.innerHTML = '<option value="">No models available</option>';
                }
                
                // Remove the old persona model population code since we now use populatePersonaModelDropdown()
                
            } catch (error) {
                console.error('Error loading models:', error);
                const modelSelect = getElement('modelSelect');
                if (modelSelect) {
                    modelSelect.innerHTML = '<option value="">Error loading models</option>';
                }
            }
        }

        // Update system metrics display
        async function updateSystemMetrics() {
            try {
                const response = await fetch('/v1/system/metrics');
                if (!response.ok) {
                    console.warn('Failed to fetch system metrics:', response.status);
                    return;
                }
                
                const metrics = await response.json();
                console.log('System metrics:', metrics);
                
                // Update the main systemMetrics div
                const systemMetricsDiv = document.getElementById('systemMetrics');
                if (systemMetricsDiv && metrics) {
                    let metricsText = '';
                    
                    // CPU usage
                    if (metrics.cpu && metrics.cpu.usage_percent !== undefined) {
                        metricsText += `CPU: ${metrics.cpu.usage_percent.toFixed(1)}% `;
                    }
                    
                    // Memory usage  
                    if (metrics.memory && metrics.memory.percent !== undefined) {
                        metricsText += `RAM: ${metrics.memory.percent.toFixed(1)}% `;
                    }
                    
                    // Temperature
                    if (metrics.temperature && metrics.temperature.cpu_celsius !== undefined) {
                        metricsText += `Temp: ${metrics.temperature.cpu_celsius.toFixed(1)}°C`;
                    }
                    
                    systemMetricsDiv.textContent = metricsText || 'Metrics unavailable';
                }
                
                // Also update individual elements if they exist (optional)
                const cpuUsage = document.getElementById('cpuUsage');
                if (cpuUsage && metrics.cpu) {
                    cpuUsage.textContent = `${metrics.cpu.usage_percent.toFixed(1)}%`;
                }
                
                const memoryUsage = document.getElementById('memoryUsage');
                if (memoryUsage && metrics.memory) {
                    memoryUsage.textContent = `${metrics.memory.percent.toFixed(1)}%`;
                }
                
                const cpuTemp = document.getElementById('cpuTemp');
                if (cpuTemp && metrics.temperature && metrics.temperature.cpu_celsius) {
                    cpuTemp.textContent = `${metrics.temperature.cpu_celsius.toFixed(1)}°C`;
                }
                
            } catch (error) {
                console.error('Error updating system metrics:', error);
                const systemMetricsDiv = document.getElementById('systemMetrics');
                if (systemMetricsDiv) {
                    systemMetricsDiv.textContent = 'Metrics error';
                }
            }
        }

        // Handle mode toggle between manual and persona
        function handleModeToggle(e) {
            currentSelectionMode = e.target.value;
            console.log(`Selection mode changed to: ${currentSelectionMode}`);
            
            const manualControls = getElement('manualControls');
            const personaControls = getElement('personaControls');
            
            if (currentSelectionMode === 'manual') {
                // Enable manual controls, disable persona
                if (manualControls) {
                    manualControls.classList.remove('disabled');
                }
                if (personaControls) {
                    personaControls.classList.add('disabled');
                }
                
                // Clear current persona selection
                const personaSelect = getElement('personaSelect');
                if (personaSelect) {
                    personaSelect.value = '';
                }
                currentPersona = null;
                
            } else if (currentSelectionMode === 'persona') {
                // Enable persona controls, disable manual
                if (manualControls) {
                    manualControls.classList.add('disabled');
                }
                if (personaControls) {
                    personaControls.classList.remove('disabled');
                }
            }
            
            // Play switch sound
            playSound('switchSound');
            
            // Update model info display
            updateModelInfo();
        }

        // Audio Control Functions
        
        // Create audio controls for a message
        function createAudioControls(messageContent, textContent) {
            const audioControls = document.createElement('div');
            audioControls.className = 'audio-controls';
            
            // Play button (browser audio)
            const playBtn = document.createElement('button');
            playBtn.className = 'audio-btn play-btn';
            playBtn.innerHTML = '▶️ Play';
            playBtn.onclick = () => playAudioInBrowser(textContent, playBtn);
            
            // Speak button (device speakers)
            const speakBtn = document.createElement('button');
            speakBtn.className = 'audio-btn speak-btn';
            speakBtn.innerHTML = '🔈 Speak';
            speakBtn.onclick = () => speakAudioOnDevice(textContent, speakBtn);
            
            audioControls.appendChild(playBtn);
            audioControls.appendChild(speakBtn);
            
            return audioControls;
        }
        
        // Generate text hash for caching
        function generateTextHash(text) {
            let hash = 0;
            for (let i = 0; i < text.length; i++) {
                const char = text.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash).toString(36);
        }
        
        // Clean text for TTS processing
        function cleanTextForTTS(text) {
            // Remove thinking tags and their content (inner thoughts should not be spoken)
            let cleaned = text
                .replace(/<think>[\s\S]*?<\/think>/gi, ' ') // Remove <think> blocks
                .replace(/<thought>[\s\S]*?<\/thought>/gi, ' ') // Remove <thought> blocks
                .replace(/<reasoning>[\s\S]*?<\/reasoning>/gi, ' ') // Remove <reasoning> blocks
                .replace(/<plan>[\s\S]*?<\/plan>/gi, ' ') // Remove <plan> blocks
                .replace(/<observe>[\s\S]*?<\/observe>/gi, ' ') // Remove <observe> blocks
                .replace(/<critique>[\s\S]*?<\/critique>/gi, ' ') // Remove <critique> blocks
                .replace(/```[\s\S]*?```/g, ' ') // Remove code blocks
                .replace(/<[^>]*>/g, ' ') // Remove remaining HTML/XML tags
                .replace(/\*\*|\*|__|\|/g, ' ') // Remove markdown formatting
                .replace(/\s+/g, ' ') // Normalize whitespace
                .trim();
            
            return cleaned;
        }
        
        // Global cooldown management
        let ttsCooldownActive = false;
        const TTS_COOLDOWN_DURATION = 2000; // 2 seconds cooldown
        
        // Apply cooldown to prevent rapid requests
        function applyTTSCooldown() {
            ttsCooldownActive = true;
            
            // Disable all TTS buttons during cooldown
            const allTTSButtons = document.querySelectorAll('.audio-controls button');
            allTTSButtons.forEach(btn => {
                btn.disabled = true;
                btn.style.opacity = '0.6';
            });
            
            setTimeout(() => {
                ttsCooldownActive = false;
                // Re-enable all TTS buttons
                allTTSButtons.forEach(btn => {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                });
            }, TTS_COOLDOWN_DURATION);
        }
        
        // Show success feedback
        function showTTSSuccess(button, message, duration = 3000) {
            const originalContent = button.innerHTML;
            button.innerHTML = `✅ ${message}`;
            button.style.background = '#28a745';
            button.style.color = 'white';
            
            setTimeout(() => {
                button.innerHTML = originalContent;
                button.style.background = '';
                button.style.color = '';
            }, duration);
        }
        
        // Get voice for current context
        function getCurrentVoice() {
            if (currentSelectionMode === 'persona' && currentPersona && currentPersona.voice) {
                return currentPersona.voice;
            }
            return 'glados'; // Default voice (simplified name)
        }
        
        // Play audio in browser
        async function playAudioInBrowser(text, button) {
            // Check cooldown
            if (ttsCooldownActive) {
                console.log('TTS cooldown active, ignoring request');
                return;
            }
            
            const cleanText = cleanTextForTTS(text);
            if (!cleanText) {
                console.warn('No clean text available for TTS');
                return;
            }
            
            // Update button state
            button.classList.add('loading');
            button.innerHTML = '▶️ Play ⏳';
            button.disabled = true;
            
            try {
                const voice = getCurrentVoice();
                const response = await fetch('/v1/tts/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: cleanText,
                        voice: voice
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data.audio_path) {
                        // Create and play audio element
                        const audio = new Audio(data.audio_path);
                        
                        // Show success feedback immediately
                        showTTSSuccess(button, 'Generated!', 1500);
                        
                        audio.play();
                        
                        // Update button during playback
                        button.innerHTML = '⏸️ Playing';
                        
                        audio.onended = () => {
                            button.classList.remove('loading');
                            button.innerHTML = '▶️ Play';
                            button.disabled = false;
                            
                            // Apply cooldown after successful playback
                            applyTTSCooldown();
                        };
                        
                        audio.onerror = () => {
                            button.classList.remove('loading');
                            button.innerHTML = '▶️ Play';
                            button.disabled = false;
                            console.error('Audio playback failed');
                        };
                    } else {
                        throw new Error('No audio path returned');
                    }
                } else {
                    throw new Error(`TTS generation failed: ${await response.text()}`);
                }
            } catch (error) {
                console.error('Error playing audio:', error);
                
                // Show error feedback
                button.innerHTML = '❌ Error';
                button.style.background = '#dc3545';
                button.style.color = 'white';
                
                setTimeout(() => {
                    button.classList.remove('loading');
                    button.innerHTML = '▶️ Play';
                    button.disabled = false;
                    button.style.background = '';
                    button.style.color = '';
                }, 2000);
            }
        }
        
        // Speak audio on device
        async function speakAudioOnDevice(text, button) {
            // Check cooldown
            if (ttsCooldownActive) {
                console.log('TTS cooldown active, ignoring request');
                return;
            }
            
            const cleanText = cleanTextForTTS(text);
            if (!cleanText) {
                console.warn('No clean text available for TTS');
                return;
            }
            
            // Update button state
            button.classList.add('loading');
            button.innerHTML = '🔈 Speak ⏳';
            button.disabled = true;
            
            try {
                const voice = getCurrentVoice();
                const response = await fetch('/v1/tts/speak', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: cleanText,
                        voice: voice
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('TTS speak request successful:', data);
                    
                    // Show success feedback
                    showTTSSuccess(button, 'Speaking!', 2000);
                    
                    // Provide visual feedback during speaking
                    button.innerHTML = '🔊 Speaking';
                    
                    // Estimate speaking duration (approximately 150 words per minute)
                    const wordCount = cleanText.split(/\s+/).length;
                    const estimatedDuration = Math.max(3000, (wordCount / 150) * 60 * 1000); // Minimum 3 seconds
                    
                    setTimeout(() => {
                        button.classList.remove('loading');
                        button.innerHTML = '🔈 Speak';
                        button.disabled = false;
                        
                        // Apply cooldown after successful speech
                        applyTTSCooldown();
                    }, estimatedDuration);
                } else {
                    throw new Error(`TTS speak request failed: ${await response.text()}`);
                }
            } catch (error) {
                console.error('Error speaking audio:', error);
                
                // Show error feedback
                button.innerHTML = '❌ Error';
                button.style.background = '#dc3545';
                button.style.color = 'white';
                
                setTimeout(() => {
                    button.classList.remove('loading');
                    button.innerHTML = '🔈 Speak';
                    button.disabled = false;
                    button.style.background = '';
                    button.style.color = '';
                }, 2000);
            }
        }
        
        // Handle automatic audio based on voice mode
        async function handleAutomaticAudio(text, messageContent) {
            if (voiceMode === 'text') {
                // No automatic playback
                return;
            }
            
            // Check cooldown for automatic audio too
            if (ttsCooldownActive) {
                console.log('TTS cooldown active, skipping automatic audio');
                return;
            }
            
            const cleanText = cleanTextForTTS(text);
            if (!cleanText) {
                console.log('No clean text available for automatic audio');
                return;
            }
            
            console.log(`Auto-audio: mode=${voiceMode}, clean text length=${cleanText.length}`);
            
            if (voiceMode === 'audio_file') {
                // Auto-play in browser
                try {
                    const voice = getCurrentVoice();
                    const response = await fetch('/v1/tts/generate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: cleanText,
                            voice: voice
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.audio_path) {
                            const audio = new Audio(data.audio_path);
                            audio.autoplay = true;
                            audio.play();
                            
                            // Apply cooldown after automatic playback starts
                            audio.onplay = () => {
                                applyTTSCooldown();
                            };
                            
                            console.log('Auto-play successful');
                        }
                    } else {
                        console.error('Auto-play generation failed:', await response.text());
                    }
                } catch (error) {
                    console.error('Auto-play failed:', error);
                }
            } 
            else if (voiceMode === 'speak') {
                // Auto-speak on device
                try {
                    const voice = getCurrentVoice();
                    const response = await fetch('/v1/tts/speak', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: cleanText,
                            voice: voice
                        })
                    });
                    
                    if (response.ok) {
                        console.log('Auto-speak successful');
                        
                        // Apply cooldown after successful auto-speak
                        applyTTSCooldown();
                    } else {
                        console.error('Auto-speak failed:', await response.text());
                    }
                } catch (error) {
                    console.error('Auto-speak failed:', error);
                }
            }
        }

        // Insert persona metadata template
        function insertPersonaTemplate() {
            // Reset all personality fields to defaults
            resetPersonalityEditor();
            
            // Show success feedback
            const templateBtn = getElement('insertTemplateBtn');
            if (templateBtn) {
                const originalText = templateBtn.textContent;
                templateBtn.innerHTML = '✅ Reset!';
                templateBtn.style.background = '#17a2b8';
                templateBtn.style.color = 'white';
                
                setTimeout(() => {
                    templateBtn.textContent = originalText;
                    templateBtn.style.background = '';
                    templateBtn.style.color = '';
                }, 1500);
            }
            
            // Play confirmation sound
            playSound('confirmSound');
        }
        
        // Reset personality editor to default values
        function resetPersonalityEditor() {
            // Reset OCEAN sliders
            getElement('openness').value = 75;
            getElement('conscientiousness').value = 85;
            getElement('extraversion').value = 60;
            getElement('agreeableness').value = 70;
            getElement('neuroticism').value = 25;
            
            // Update trait value displays
            updateOceanValues();
            
            // Clear text areas
            getElement('personaIdentity').value = '';
            getElement('personaCore').value = '';
            getElement('personaFramework').value = '';
            getElement('personaRecentEvents').value = '';
            getElement('personaTrance').value = '';
            getElement('personaBehavior').value = '';
            
            // Reset emoji
            getElement('personaEmojiDisplay').textContent = '🤖';
            
            // Clear test chat
            clearTestChat();
        }
        
        // Update OCEAN trait value displays
        function updateOceanValues() {
            const traits = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'neuroticism'];
            traits.forEach(trait => {
                const slider = getElement(trait);
                const valueDisplay = slider?.nextElementSibling;
                if (slider && valueDisplay) {
                    valueDisplay.textContent = slider.value + '%';
                }
            });
        }
        
        // Compile personality editor into system message
        function compilePersonalityToSystemMessage() {
            const openness = getElement('openness')?.value || 75;
            const conscientiousness = getElement('conscientiousness')?.value || 85;
            const extraversion = getElement('extraversion')?.value || 60;
            const agreeableness = getElement('agreeableness')?.value || 70;
            const neuroticism = getElement('neuroticism')?.value || 25;
            
            const identity = getElement('personaIdentity')?.value || '[Identity not defined]';
            const core = getElement('personaCore')?.value || '[Core philosophy not defined]';
            const framework = getElement('personaFramework')?.value || '[Behavioral framework not defined]';
            const recentEvents = getElement('personaRecentEvents')?.value || '[Recent context not defined]';
            const trance = getElement('personaTrance')?.value || '[Trigger states not defined]';
            const behavior = getElement('personaBehavior')?.value || '[Communication style not defined]';
            
            return `<personality>
Openness: ${openness}%
Conscientiousness: ${conscientiousness}%
Extraversion: ${extraversion}%
Agreeableness: ${agreeableness}%
Neuroticism: ${neuroticism}%
</personality>

<identity>
${identity}
</identity>

<core>
${core}
</core>

<framework>
${framework}
</framework>

<recentEvents>
${recentEvents}
</recentEvents>

<trance>
${trance}
</trance>

${behavior}`;
        }
        
        // Parse system message into personality editor components
        function parseSystemMessageToPersonality(systemMessage) {
            if (!systemMessage) return;
            
            // Extract OCEAN values
            const personalityMatch = systemMessage.match(/<personality>([\s\S]*?)<\/personality>/);
            if (personalityMatch) {
                const personalityText = personalityMatch[1];
                const traits = {
                    openness: personalityText.match(/Openness:\s*(\d+)%/)?.[1] || 75,
                    conscientiousness: personalityText.match(/Conscientiousness:\s*(\d+)%/)?.[1] || 85,
                    extraversion: personalityText.match(/Extraversion:\s*(\d+)%/)?.[1] || 60,
                    agreeableness: personalityText.match(/Agreeableness:\s*(\d+)%/)?.[1] || 70,
                    neuroticism: personalityText.match(/Neuroticism:\s*(\d+)%/)?.[1] || 25
                };
                
                Object.entries(traits).forEach(([trait, value]) => {
                    const element = getElement(trait);
                    if (element) element.value = value;
                });
                
                updateOceanValues();
            }
            
            // Extract other sections
            const sections = {
                personaIdentity: /<identity>([\s\S]*?)<\/identity>/,
                personaCore: /<core>([\s\S]*?)<\/core>/,
                personaFramework: /<framework>([\s\S]*?)<\/framework>/,
                personaRecentEvents: /<recentEvents>([\s\S]*?)<\/recentEvents>/,
                personaTrance: /<trance>([\s\S]*?)<\/trance>/
            };
            
            Object.entries(sections).forEach(([elementId, regex]) => {
                const match = systemMessage.match(regex);
                const element = getElement(elementId);
                if (match && element) {
                    element.value = match[1].trim();
                }
            });
            
            // Extract behavior description (everything after the last closing tag)
            const lastTagMatch = systemMessage.match(/.*<\/\w+>\s*([\s\S]*?)$/);
            const behaviorElement = getElement('personaBehavior');
            if (lastTagMatch && behaviorElement) {
                // Clean the behavior text to remove any remaining tags
                let behaviorText = lastTagMatch[1].trim();
                // Remove any remaining XML/HTML tags
                behaviorText = behaviorText.replace(/<[^>]*>/g, '').trim();
                behaviorElement.value = behaviorText;
            }
        }
        
        // Auto-detect available voices
        async function detectAvailableVoices() {
            try {
                // Try to detect voices from the backend
                const response = await fetch('/v1/tts/voices');
                if (response.ok) {
                    const data = await response.json();
                    let voices = data.voices || ['glados', 'jarvis']; // Default fallback
                    
                    // Filter out any remaining hidden files or system artifacts
                    voices = voices.filter(voice => 
                        voice && 
                        !voice.startsWith('.') && 
                        !voice.startsWith('_') &&
                        voice.trim() !== ''
                    );
                    
                    // Ensure we have at least some voices
                    if (voices.length === 0) {
                        console.warn('No valid voices detected, using defaults');
                        voices = ['glados', 'jarvis'];
                    }
                    
                    console.log('Filtered available voices:', voices);
                    return voices;
                }
            } catch (error) {
                console.log('Voice detection failed, using defaults:', error);
            }
            
            // Fallback to default voices
            return ['glados', 'jarvis'];
        }
        
        // Update voice dropdown with available voices
        async function updateVoiceOptions() {
            const voiceSelect = getElement('personaVoice');
            const personaVoiceSelect = getElement('personaVoice'); // This is the same element, but let's also handle the persona creator one
            
            if (!voiceSelect) return;
            
            const availableVoices = await detectAvailableVoices();
            
            // Clear current options for main voice dropdown
            voiceSelect.innerHTML = '';
            
            // Add voice options with smart name parsing
            availableVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice;
                
                // Parse voice name intelligently
                let displayName = voice;
                
                // Check if it has common name mapping first
                const commonNames = {
                    'glados': 'GlaDOS',
                    'jarvis': 'Jarvis'
                };
                
                if (commonNames[voice.toLowerCase()]) {
                    displayName = commonNames[voice.toLowerCase()];
                } else {
                    // Parse filename format: en_US-john-medium or en_US-john
                    const parts = voice.split('-');
                    if (parts.length === 3) {
                        // en_US-john-medium -> john
                        displayName = parts[1];
                    } else if (parts.length === 2) {
                        // en_US-john -> john
                        displayName = parts[1];
                    } else {
                        // Single word or other format, use as-is
                        displayName = voice;
                    }
                    
                    // Title case the result
                    displayName = displayName.charAt(0).toUpperCase() + displayName.slice(1).toLowerCase();
                }
                
                option.textContent = displayName;
                voiceSelect.appendChild(option);
            });
            
            console.log(`Detected ${availableVoices.length} voices:`, availableVoices);
        }
        
        // Populate persona voice dropdown with available voices
        async function populatePersonaVoiceDropdown() {
            const personaVoiceSelect = getElement('personaVoice');
            if (!personaVoiceSelect) return;
            
            const availableVoices = await detectAvailableVoices();
            
            // Clear current options
            personaVoiceSelect.innerHTML = '';
            
            // Add voice options with smart name parsing and icons
            availableVoices.forEach((voice, index) => {
                const option = document.createElement('option');
                option.value = voice;
                
                // Parse voice name intelligently
                let displayName = voice;
                let icon = '🔊'; // Default icon
                
                // Check if it has common name mapping first
                const commonNames = {
                    'glados': { name: 'GlaDOS', icon: '🤖' },
                    'jarvis': { name: 'Jarvis', icon: '🎩' }
                };
                
                if (commonNames[voice.toLowerCase()]) {
                    displayName = commonNames[voice.toLowerCase()].name;
                    icon = commonNames[voice.toLowerCase()].icon;
                } else {
                    // Parse filename format: en_US-john-medium or en_US-john
                    const parts = voice.split('-');
                    if (parts.length === 3) {
                        // en_US-john-medium -> john
                        displayName = parts[1];
                    } else if (parts.length === 2) {
                        // en_US-john -> john
                        displayName = parts[1];
                    } else {
                        // Single word or other format, use as-is
                        displayName = voice;
                    }
                    
                    // Title case the result
                    displayName = displayName.charAt(0).toUpperCase() + displayName.slice(1).toLowerCase();
                    
                    // Assign gender-neutral icon for unknown voices
                    icon = '🗣️';
                }
                
                option.textContent = `${icon} ${displayName}`;
                
                // Select first voice as default
                if (index === 0) {
                    option.selected = true;
                }
                
                personaVoiceSelect.appendChild(option);
            });
            
            console.log(`Populated persona voice dropdown with ${availableVoices.length} voices:`, availableVoices);
        }

        // OCEAN slider event listeners
        const oceanTraits = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'neuroticism'];
        oceanTraits.forEach(trait => {
            const slider = getElement(trait);
            if (slider) {
                slider.addEventListener('input', updateOceanValues);
            }
        });

        // Initialize voice detection
        updateVoiceOptions();
        
        // Mode toggle event listeners
        const manualModeRadio = getElement('manualModeRadio');
        const personaModeRadio = getElement('personaModeRadio');
        
        // Test persona event listeners
        const testPersonaBtn = getElement('testPersonaBtn');
        if (testPersonaBtn) {
            testPersonaBtn.addEventListener('click', testPersona);
        }
        
        const testMessageInput = getElement('testMessageInput');
        if (testMessageInput) {
            testMessageInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    testPersona();
                }
            });
        }

        // Test persona functionality
        async function testPersona() {
            const testInput = getElement('testMessageInput');
            if (!testInput) return;
            
            const testMessage = testInput.value.trim();
            if (!testMessage) return;
            
            // Add user message to test chat
            addTestMessage('user', testMessage);
            testInput.value = '';
            
            // Add typing indicator
            const typingMessageId = addTestMessage('assistant', 'Thinking...', true);
            
            try {
                // Compile current personality into system message
                const systemMessage = compilePersonalityToSystemMessage();
                
                // Get current model (use default if none selected)
                const selectedModel = getElement('personaModel')?.value || currentModel || 'default';
                
                // Create test messages array
                const messages = [
                    { role: 'system', content: systemMessage },
                    { role: 'user', content: testMessage }
                ];
                
                // Send test request to API
                const response = await fetch('/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: selectedModel,
                        messages: messages,
                        max_tokens: 150,
                        temperature: parseFloat(getElement('personaTemperature')?.value || 0.7),
                        stream: false
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const assistantResponse = data.choices[0].message.content;
                    
                    // Remove typing indicator and add real response
                    removeTestMessage(typingMessageId);
                    addTestMessage('assistant', assistantResponse);
                } else {
                    // Show error message
                    removeTestMessage(typingMessageId);
                    addTestMessage('assistant', 'Sorry, I encountered an error during testing. Please check your settings and try again.');
                }
                
            } catch (error) {
                console.error('Error testing persona:', error);
                removeTestMessage(typingMessageId);
                addTestMessage('assistant', 'Error: Could not connect to the server for testing.');
            }
        }
        
        // Add a test message to the test chat container
        function addTestMessage(role, content, isTyping = false) {
            const testContainer = getElement('testChatContainer');
            if (!testContainer) return null;
            
            const messageId = Date.now() + Math.random();
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `test-message ${role}`;
            messageDiv.setAttribute('data-message-id', messageId);
            
            if (isTyping) {
                messageDiv.classList.add('typing');
            }
            
            // Get persona emoji or default
            const personaEmoji = getElement('personaEmojiDisplay')?.textContent || '🤖';
            const avatar = role === 'user' ? '👤' : personaEmoji;
            
            messageDiv.innerHTML = `
                <div class="test-avatar">${avatar}</div>
                <div class="test-content">${content}</div>
            `;
            
            testContainer.appendChild(messageDiv);
            testContainer.scrollTop = testContainer.scrollHeight;
            
            return messageId;
        }
        
        // Remove a test message by ID
        function removeTestMessage(messageId) {
            if (!messageId) return;
            
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                messageElement.remove();
            }
        }
        
        // Clear test chat
        function clearTestChat() {
            const testContainer = getElement('testChatContainer');
            if (!testContainer) return;
            
            testContainer.innerHTML = `
                <div class="test-message assistant">
                    <div class="test-avatar">🤖</div>
                    <div class="test-content">
                        Hello! I'm ready to be tested. Ask me anything to see how I respond with the current personality settings.
                    </div>
                </div>
            `;
        }
        
        const clearTestBtn = getElement('clearTestBtn');
        if (clearTestBtn) {
            clearTestBtn.addEventListener('click', clearTestChat);
        }

        // Sample voice functionality
        async function sampleVoice() {
            const voiceSelect = getElement('personaVoice');
            const sampleBtn = getElement('sampleVoiceBtn');
            
            if (!voiceSelect || !sampleBtn) {
                console.error('Voice dropdown or sample button not found');
                return;
            }
            
            let selectedVoice = voiceSelect.value;
            const personaName = getElement('personaName')?.value?.trim() || 'AI Assistant';
            
            // Debug logging
            console.log('Sample voice requested:', selectedVoice);
            console.log('Available options:', Array.from(voiceSelect.options).map(opt => opt.value));
            
            // Validate and provide fallback for voice selection
            if (!selectedVoice || selectedVoice === '' || selectedVoice === 'Loading voices...') {
                console.warn('No voice selected or still loading, using default');
                selectedVoice = 'glados'; // Use default fallback
            }
            
            // Sample texts based on voice with more comprehensive mapping
            const sampleTexts = {
                'glados': `Hello, I'm ${personaName}. Welcome to the CodeDeck interface. I'm here to assist you with your queries.`,
                'en_US-GlaDOS-medium': `Hello, I'm ${personaName}. Welcome to the CodeDeck interface. I'm here to assist you with your queries.`,
                'jarvis': `Good day, I am ${personaName}. How may I be of service to you today?`,
                'en_GB-jarvis-medium': `Good day, I am ${personaName}. How may I be of service to you today?`,
                'default': `Hello, this is ${personaName}. I'm ready to help you with whatever you need.`
            };
            
            const sampleText = sampleTexts[selectedVoice.toLowerCase()] || sampleTexts['default'];
            
            console.log('Using sample text:', sampleText);
            console.log('Using voice:', selectedVoice);
            
            // Update button state
            sampleBtn.innerHTML = '🔊 Playing...';
            sampleBtn.disabled = true;
            sampleBtn.style.opacity = '0.7';
            
            try {
                const requestPayload = {
                    text: sampleText,
                    voice: selectedVoice
                };
                
                console.log('Sending TTS request:', requestPayload);
                
                const response = await fetch('/v1/tts/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestPayload)
                });
                
                console.log('TTS response status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('TTS response data:', data);
                    
                    if (data.audio_path) {
                        // Create and play audio element
                        const audio = new Audio(data.audio_path);
                        
                        // Show success feedback
                        sampleBtn.innerHTML = '✅ Playing';
                        sampleBtn.style.background = '#28a745';
                        sampleBtn.style.color = 'white';
                        
                        audio.play();
                        
                        audio.onended = () => {
                            // Reset button after playback
                            setTimeout(() => {
                                sampleBtn.innerHTML = '🔊 Sample';
                                sampleBtn.disabled = false;
                                sampleBtn.style.opacity = '1';
                                sampleBtn.style.background = '';
                                sampleBtn.style.color = '';
                            }, 1000);
                        };
                        
                        audio.onerror = () => {
                            console.error('Audio playback error');
                            // Reset on error
                            sampleBtn.innerHTML = '❌ Audio Error';
                            sampleBtn.style.background = '#dc3545';
                            sampleBtn.style.color = 'white';
                            
                            setTimeout(() => {
                                sampleBtn.innerHTML = '🔊 Sample';
                                sampleBtn.disabled = false;
                                sampleBtn.style.opacity = '1';
                                sampleBtn.style.background = '';
                                sampleBtn.style.color = '';
                            }, 2000);
                        };
                    } else {
                        throw new Error('No audio path returned from server');
                    }
                } else {
                    const errorText = await response.text();
                    console.error('TTS request failed:', response.status, errorText);
                    throw new Error(`Voice sample failed (${response.status}): ${errorText}`);
                }
                
            } catch (error) {
                console.error('Error sampling voice:', error);
                
                // Show error feedback with more detail
                sampleBtn.innerHTML = '❌ Error';
                sampleBtn.style.background = '#dc3545';
                sampleBtn.style.color = 'white';
                
                // Show error details in console for debugging
                alert(`Voice sample failed: ${error.message}\n\nCheck console for more details.`);
                
                setTimeout(() => {
                    sampleBtn.innerHTML = '🔊 Sample';
                    sampleBtn.disabled = false;
                    sampleBtn.style.opacity = '1';
                    sampleBtn.style.background = '';
                    sampleBtn.style.color = '';
                }, 3000);
            }
        }

        const sampleVoiceBtn = getElement('sampleVoiceBtn');
        if (sampleVoiceBtn) {
            sampleVoiceBtn.addEventListener('click', sampleVoice);
        }

        const regeneratePersonaBtn = getElement('regeneratePersonaBtn');
        if (regeneratePersonaBtn) {
            regeneratePersonaBtn.addEventListener('click', regeneratePersona);
        }

        // Toggle think tags in speech
        function toggleThinkTags() {
            speakThinkTags = !speakThinkTags;
            
            const toggleBtn = getElement('thinkTagsToggle');
            if (toggleBtn) {
                // Update button appearance based on state
                if (speakThinkTags) {
                    toggleBtn.style.color = '#28a745'; // Green when enabled
                    toggleBtn.style.backgroundColor = 'rgba(40, 167, 69, 0.1)';
                    toggleBtn.title = 'Think tags will be spoken (click to disable)';
                } else {
                    toggleBtn.style.color = '#6c757d'; // Gray when disabled
                    toggleBtn.style.backgroundColor = 'transparent';
                    toggleBtn.title = 'Think tags will NOT be spoken (click to enable)';
                }
            }
            
            // Save to config
            saveConfig();
            
            // Play confirmation sound
            playSound('switchSound');
            
            console.log('Think tags speaking:', speakThinkTags ? 'enabled' : 'disabled');
        }

        const thinkTagsToggle = getElement('thinkTagsToggle');
        if (thinkTagsToggle) {
            thinkTagsToggle.addEventListener('click', toggleThinkTags);
        }
    </script>
</body>
</html> 